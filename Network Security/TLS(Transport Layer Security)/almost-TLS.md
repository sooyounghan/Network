-----
### almost-TLS
-----
1. TLS의 단순화된 버전
2. TLS와 마찬가지로 핸드쉐이크(Handshake), 키 유도(Key Derivation), 데이터 전송(Data Transfer)라는 세 가지 단계로 구성
   - 클라이언트(밥)와 서버(앨리스) 간 통신 세션을 위한 세 단계로 구성
   - 앨리스는 개인 키 / 공용 키 쌍을 가지며 그녀의 신원을 공개키와 관련하여 인증받았음

3. 핸드쉐이크(Handshake)
<div align="center">
<img src="https://github.com/user-attachments/assets/3bc07c29-307c-4fd7-864d-6a20b30ba7e0">
</div>

   - 밥은 앨리스와 TCP 연결을 설립
   - 그 앨리스가 진짜 앨리스인지 확인
   - TLS 세션에 필요한 모든 대칭키를 생성하기 위해 앨리스와 밥이 사용할 주 비밀 키(Master Secret Key)를 앨리스에게 전송
   - 일단, TCP 연결이 설립되면, 밥은 앨리스에게 Hello 메세지를 보내며, 앨리스는 그녀의 공개키를 담은 인증서로 응답 (인증서는 CA에 의해 인증받았으므로, 밥은 인증서 내 공개키가 앨리스의 것이라는 사실을 믿음)
   - 밥은 MS(Master Secret, TLS 세션 내에서만 사용)를 생성하고, 이를 앨리스의 공개키로 암호화하여 EMS(Encrypted Master Secret)를 만듬
   - 이 EMS가 앨리스에게 전송되고 앨리스는 자신의 개인키를 가지고 EMS를 복호화함으로써 MS를 얻음
   - 이 단계를 거치면서, 밥과 앨리스 모두 TLS에 대한 MS를 알게 됨 (다른 사람들은 모름)

4. 키 유도
   - 밥과 앨리스가 공유한 MS는 이후 모든 암호화와 데이터 무결성 검사를 위한 대칭 세션키로 사용
   - 일반적으로 앨리스와 밥이 각각 다른 암호화 키를 사용하고, 암호화와 무결성 검사에도 서로 다른 키를 사용하는 것이 더 안전함
   - 따라서, 앨리스와 밥은 MS를 이용해 4개의 키를 생성
     + $E_{B}$ : 밥이 앨리스에게 보내는 데이터에 대한 세션 암호화 키
     + $M_{B}$ : 밥이 앨리스에게 보내는 세션 HMAC 키 (HMAC는 표준화된 해시 메세지 인증 코드 의미)
     + $E_{A}$ : 앨리스가 밥에게 보내는 데이터에 대한 세션 암호화 키
     + $M_{A}$ : 앨리스가 밥에게 보내는 세션 HMAC 키 (HMAC는 표준화된 해시 메세지 인증 코드 의미)
    
   - 앨리스와 밥은 MS로부터 각각 4개의 키를 생성하고, 이는 단순히 MS를 4개의 키로 나눈 것
   - 키 유도 단계 마지막에 이르면, 앨리스와 밥 모두 4개의 키를 가지며, 2개의 암호화 키는 데이터를 암호화하는데 사용, 2개의 HMAC 키는 데이터 무결성을 확인하는데 사용

5. 데이터 전송
   - 앨리스와 밥이 같은 4개의 세션 키($E_{B}$, $M_{B}$, $E_{A}$, $M_{A}$)를 공유하므로, TCP 연결을 통해 서로에게 안전한 데이터를 보낼 수 있음
   - TCP가 바이트 스트림 프로토콜이므로, 자연스러운 방법은 TLS가 애플리케이션 데이터를 끊임없이 암호화하고 암호화된 데이터를 TCP에 쉴 새 없이 전달하는 것
   - 그러나 이런 과정 중에 무결성 검사를 위한 HAMC이 실행되어야함
     + 전체 세션 시간 동안 전송된 밥의 모든 데이터 무결성을 확인하는 일을 TCP 세션이 종료될 때까지 미룰 수 없음
     + 따라서, TLS는 데이터 스트림을 레코드(Record)로 쪼개고, 각 레코드에 무결성 검사를 위한 HMAC를 덧붙인 후, 레코드 + HMAC로 암호화를 함
     + HMAC을 생성하기 위해 레코드 데이터와 키 $M_{B}$를 해시 함수에 넣어 레코드 + HMAC 꾸러미를 암호화하기 위해 밥은 그의 세션 암호화 키 $E_{B}$ 사용
     + 이렇게 암호화된 꾸러미는 인터넷 상으로 전송하기 위해 TCP로 보내짐
   - 문제점 : 가운데 사람(Woman-in-the-middle, 중간 공격자)가 존재하고, 앨리스와 밥 사이 전송되는 TCP 세그먼트 스트림에서 스트림을 삽입, 삭제, 교환할 수 있다고 가정
     + 예를 들면, 밥이 보낸 2개의 세그먼트를 잡아내서 순서를 바꾼 후 TCP 세그먼트 번호(암호화 되지 않음)까지 그에 맞게 변경해 순서가 바뀐 두 세그먼트를 앨리스에게 보냄 (각 TCP 세그먼트가 정확히 한 레코드씩 담겨있다고 가정)
     + 앨리스 쪽 TCP는 모든게 잘 처리되었다고 생각하고 그 두 레코드를 TLS 부계층으로 전달
     + 앨리스 쪽 TLS가 두 레코드 복호화
     + 앨리스 쪽 TLS가 각 레코드의 HMAC을 사용해 두 레코드의 데이터 무결성 확인
     + TLS는 두 레코드의 복호화된 바이트 스트림을 애플리케이션 계층에 넘겨주는데, 순서가 뒤바뀐 두 레코드 때문에 앨리스가 받은 전체 바이트 스트림은 순서가 맞지 않음

   - 해결책 : 순서 번호 사용
     + 밥은 순서 번호 카운터를 유지하는데, 0부터 시작해서 TLS 레코드를 하나씩 보낼 때마다 하나씩 증가
     + 순서 번호를 레코드 자체에 포함하는 것이 아니라 HMAC을 계산할 때 포함
     + 그러므로 HMAC은 데이터와 HMAC 키 $M_{B}$, 그리고 현재 순서 번호를 합친 결과의 해시값
     + 앨리스는 밥의 순서 번호를 추적해서 자신이 HMAC을 계산할 때 적절한 순서 번호를 포함시킴으로써 레코드의 데이터 무결성을 확인할 수 있음
     + TLS 순서 번호의 이러한 사용은 중간자 공격을 수행해 세그먼트 순서를 바꾸거나 재생하지 못하게 함

6. TLS 레코드
<div align="center">
<img src="https://github.com/user-attachments/assets/777e9031-24f7-49a4-8658-3258ed4f9a00">
</div>

   - 레코드는 타입 / 버전 / 길이 / 데이터 / HMAC 필드로 구성
   - 처음 세 필드는 암호화되지 않음
   - 타입 필드는 레코드가 핸드세이크 메세지인지, 애플리케이션 데이터를 담은 메세지인지 나타내며, TLS 연결을 종료하기 위해서도 사용
   - 수신자의 TLS로 들어오는 TCP 바이트 스트림으로부터 TLS 레코드를 뽑아내기 위해 길이 필드 사용
