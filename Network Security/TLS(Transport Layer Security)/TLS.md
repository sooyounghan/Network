----
### TLS
----
1. TLS 핸드세이크
   - TLS는 앨리스나 밥에게 특정 대칭키 알고리즘이나 공개키 알고리즘을 사용하도록 강제하지 않음
   - 대신, TLS는 앨리스와 밥이 TLS 세션의 처음인 핸드세이크 단계에서 사용할 암호화 알고리즘을 합의하게 함
   - 핸드세이크 단계 동안 앨리스와 밥은 서로에게 넌스를 보내는데, 이는 세션키 ($E_{B}$, $M_{B}$, $E_{A}$, $M_{A}$)를 생성하는데 사용
   - TLS의 핸드세이크 과정
     + 클라이언트는 넌스와 함께 자신이 지원하는 암호화 알고리즘 목록을 보냄
     + 목록으로부터 서버는 대칭키 알고리즘(예) AES), 공개키 알고리즘(예) 특정 길이 키를 갖는 RSA), 그리고 HMAC 키와 함께 HMAC 알고리즘(MD5 또는 SHA-1)을 선택하며, 서버는 자신의 선택 결과와 인증서, 서버 넌스를 클라이언트에게 돌려줌
     + 클라이언트는 인증서를 확인하고 서버의 공캐키를 알아낸 후 PMS(Pre-Master Secret)을 생성 (PMS를 서버의 공캐키로 암호화한 후 서버에게 보냄)
     + 클라이언트와 서버는 같은 키 유도 함수(TLS 표준에 지정된)를 사용하여 PMS와 넌스로부터 독립적인 MS(Master Secret)을 계산하며, 이후 MS는 2개의 암호화 키와 2개의 HMAC 키를 생성하기 위해 분할 : 선택된 대칭 암호화 CBC(3DES나 AES 같은)를 이용한다면 연결의 양측을 위해 하나씩, 총 2개의 IV(Initialization Vector)를 MS로부터 얻고, 이후 클라이언트와 서버 간 모든 메세지는 암호화되고 인증 (HMAC 이용)
     + 클라이언트는 모든 핸드세이크 메세지의 HMAC를 전송
     + 서버는 모든 핸드세이크 메세지의 HMAC 전송

   - 마지막 두 단계는 핸드세이크가 훼손되는 것을 방지
     + 이를 위해 첫 단계에는 클라이언트는 알고리즘 목록을 제공하는데, 어떤 것은 강하고 약한데, 아직 암호화 알고리즘과 키에 대한 합의가 이루어지지 않았으므로 알고리즘 목록은 평문으로 전송
     + 가운데 사람은 이 목록에서 강한 알고리즘들을 삭제해 서버가 약한 알고리즘을 선택하도록 할 수 밖에 없음
     + 이러한 훼손 공격을 막기 위해 클라이언트는 주고받은 모든 핸드세이크 메세지를 연결한 후 HMAC를 전송
     + 서버는 이 MAC을 모든 핸드세이크 메세지에 대해 자신이 만든 HMAC과 비교
     + 만약, 어떤 불일치가 발견되면, 서버는 연결을 종료할 수 있으며, 서버가 핸드세이크 메세지의 HMAC을 전송하면 클라이언트가 불일치 검사 수행

   - 넌스가 사용되는 이유
     + 세그먼트 공격을 방지하기 위해서는 순서 번호로 충분하지만, 연결 재생 공격은 막지 못함
     + 예시) 가운데 사람이 앨리스와 밥 사이의 모든 메세지를 엿듣게 되고, 다음 날 밥으로 가장하여 전날 밥이 앨리스에게 보낸 메세지들을 정확히 같은 순서로 전송
       * 앨리스가 넌스를 사용하지 않으면, 그 날 전송했던 정확히 같은 순서의 메세지들로 응답할 것이고, 자신이 받는 모든 메세지가 무결성 검사를 통과하므로 의심하지 않음
       * 만약, 전자상거래 서버였다면, 엄청난 문제가 발생
       * 한편, 프로토콜에 넌스를 포함하게 되면, 앨리스는 각 TCP 연결마다 서로 다른 넌스를 보낼 것이고 두 날에 사용되는 암호화 키가 달라지므로, 앨리스가 가운데 사람이 재생해서 보낸 TLS 레코드를 받았을 때 레코드들은 무결성 검사에 실패
     + 💡 즉, TLS에서 넌스는 연결 재생 공격에 대응하기 위해 사용되고, 순서 번호는 진행 중인 세션에서 개별 패킷들의 재생에 대응하기 위해 사용

2. 연결 종료
   - 어느 순간에는 밥이나 앨리스가 TLS 세션을 끝내길 원할 것
   - 한 가지 방법 : 단순히 하부의 TCP 연결을 끊음으로 TLS 세션 종료 (즉, 밥이 앨리스에게 TCP FIN 세그먼트를 전송)
   - 그러나 단순한 설계는 절단 공격(Truncation Attack)을 허용하게 되는데, 가운데 사람이 진행 중인 TLS 세션에 다시 한 번 끼어들어 TCP FIN을 이용해 세션을 일찍 종료 (이런 경우, 앨리스는 사실 상 밥의 데이터를 일부만 받았지만, 모두 받았다고 생각)
   - 해결책은 레코드 타입 필드에 그 레코드가 TLS 세션 종료를 수행할 것인지 표시하는 것 (TLS 타입이 암호화 없이 보내지더라도 수신 측에서 레코드의 HMAC을 이용해 인증하므로 문제 없음)
   - 그러한 필드를 포함시킴으로, 만일 앨리스가 종료 TLS를 받기 전에 TCP FIN을 받게 되면, 수상함을 감지할 수 있음
