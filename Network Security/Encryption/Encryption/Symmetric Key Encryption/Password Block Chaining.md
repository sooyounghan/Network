-----
### 암호 블록 체이닝
-----
1. 컴퓨터 네트워크 애플리케이션에서는 일반적으로 긴 메세지(또는 긴 데이터 스트림)를 암호화 할 필요가 있음
   - 블록 암호화를 이용하여 메세지를 k비트 블록으로 쪼갠 후 각 블록을 독립적으로 암호화하면, 중요 문제가 발생
   - 대표적으로 2개 이상의 평문 블록이 동일할 수 있음

2. 동일한 평문 블록에 대해 블록 암호화 기법은 같은 암호문을 생성할 수 있는데, 이는 공격자가 이를 발견하게 되면 원문을 추측해낼 수 있는 가능성 존재
   - 동일 암호문 블록의 발견에다 하위 프로토콜 구조에 대한 지식까지 있다면 전체 메세지 복호화 가능성 존재

3. 따라서, 이 문제를 해결하기 위해 평문 블록이 동일하더라도 다른 암호문 블록이 생성될 수 있도록 기존 암호화 기술에 임의성(Randomness) 추가
   - i번쨰 평문 블록과 암호문 블록은 $m(i)$, $c(i)$이라고 하고, a ⊕ b 는 두 비트열의 배타적 논리합(Exclusive-or, XOR)
     + 배타적 논리합 : 0 ⊕ 0 = 1 ⊕ 1 = 0, 1 ⊕ 0 = 0 ⊕ 1 = 1을 의미하고, 두 비트열 간의 XOR는 비트 단위로 수행
   - 키가 S인 블록 암호화 알고리즘은 $K_{s}$로 표현
   - 기본 적인 아이디어
     + 송신자는 i번째 블록을 위해 k비트 길이의 임의의 수 r(i)를 생성하고, c(i) = $K_{s}$(m(i) ⊕ r(i))를 계산 : 각 블록에 대해 새로운 k비트의 임의의 수가 선택됨
     + 이후 송신자는, c(1), r(1), c(2), r(2), ... 같은 방식으로 전송 : 수신자는 c(i)과 r(i)을 받아서 m(i) = $K_{s}$(c(i) ⊕ r(i))를 계산하여 평문의 각 블록을 복원
     + r(i)은 암호화가 되지 않은 채 전달되고, 공격자가 감청할 수 있을지라도 키 S를 알지 못하므로 평문 m(i)는 복호화할 수 없음
     + 또한, 두 평문 블록 m(i)와 m(j)가 같더라도 대응되는 암호문 블록 c(i)와 c(j)는 서로 달라질 것 (단, 임의의 수 r(i)과 r(j)가 서로 다른 경우에 한해 매우 높은 확률로 그렇게 됨)

4. 예시 - 3비트 블록 암호화 가정
   - 원문 010010010이라 할때, 임의성을 포함시키지 않고 표만을 이용해 암호화하면 101101101이 됨
   - 반면에 임의의 블록 r(1) = 001, r(2) = 111, r(3) = 100을 생성하여 적용한다면, 암호문 블록은 r(1) = 100, r(2) = 010, r(3) = 000이 됨 (즉, 평문 블록이 동일함에도 불구하고 3개의 암호문 블록이 서로 다름)
   - 이후, c(1), r(1), c(2), r(2), ... 순서로 전송하게 되며, 공유키 $K_{s}$를 사용해 원래 평문을 얻을 수 있음

5. 문제점
   - 두 배 많은 비트를 전송해야 함
   - 암호화된 한 비트마다 임의의 수 한 비트를 전송해야 하므로 두 배의 대역폭이 필요
   - 해결 방법 : 암호 블록 체이닝(Cipher Block Chaining, CBC)이라는 기법 사용
     + 첫 번째 메세지와 함께 임의의 수를 단 한 번만 전송하고, 이후 임의의 수로는 직전 계산된 암호문 블록을 대신 사용
   - CBC 동작 방식
     + 메세지 혹은 데이터 스트림을 암호화하기 전 송신자는 초기화 벡터(Initialization Vector, IV)라 불리는 임의의 k비트열을 생성 (초기화 벡터를 c(0)이라고 가정) 후, 송신자는 이 초기화 벡터를 평문 형태로 수신자에게 보냄
     + 첫 번째 블록에 대해 송신자는 m(1) ⊕ c(0)을 계산 : 즉, 평문의 첫 번째 블록과 IV의 배타적 논리합을 구한 뒤, 그 결과로 블록 암호화 알고리즘의 입력으로 사용하여 해당하는 암호문 블록을 얻음 (즉, c(1) = $K_{s}$(m(1) ⊕ c(0))이며, 송신자는 이 암호화된 블록 c(1)을 수신자에게 전송)
     + i번째 블록에 대해 송신자는 c(i) = $K_{s}$(m(i) ⊕ c(i - 1))의 식을 이용해 i번째 암호문 블록 생성

6. CBC의 결과
   - 수신자는 여전히 원래 메세지를 복구할 수 있음
     + 수신자가 c(i)를 받으면, $K_{s}$로 복화하해서 s(i) = m(i) ⊕ c(i - 1)를 얻음
     + 수신자는 또한 c(i - 1)를 알고 있으므로, m(i) = s(i) ⊕ c(i - 1)를 통해 원래의 평문을 알아낼 수 있음

   - 두 평문이 동일하더라도 해당 암호문들은 (거의 모든 경우) 서로 달라질 것임
   - 송신자가 초기화 벡터 IV를 암호화하지 않고 보내더라도 침입자는 비밀키 S를 모르므로, 암호문 블록을 여전히 해독해낼 수 없음
   - 송신자는 단지 하나의 블록(IV)만을 전송하면 되므로 긴 메세지(수백개 블록으로 이루어진) 대비 요구되는 대역폭 증가량은 미미

7. CBC 예시
   - 평문은 010010010, IV = c(0) = 001인 경우
   - 먼저 송신자는 c(1) = $K_{s}$(m(1) ⊕ c(0)) = 100을 계산하기 위해 IV 사용
   - 이후 송신자는 c(2) = $K_{s}$(m(2) ⊕ c(1)) = $K_{s}$(010 ⊕ 100) = 000과 c(3) = $K_{s}$(m(3) ⊕ c(2)) = $K_{s}$(010 ⊕ 100)) = 101을 차례로 계산
   - 수신자는 IV와 $K_{s}$를 알고 있으므로 원문 복원 가능

8. 안전한 네트워크 프로토콜 설계에 있어서 CBC는 중요 역할을 하며, 프로토콜 내 송신자가 수신자에게 IV를 전송할 수 있는 수단을 제공해야 함
