-----
### 종단점 인증
-----
1. 하나의 통신 개체가 다른 개체에게 자신의 신원을 컴퓨터 네트워크상으로 증명하는 작업
   - 예시) 전자메일 사용자가 서버에 신원을 입증하는 것
   - 서로를 인증해야 하는 것은 라우터나 클라이언트 / 서버 프로세스 같은 네트워크 요소

2. 인증은 인증 프로토콜(Authencation Protocol)의 한 부분으로서 교환된 메세지와 데이터만을 기반으로 수행
   - 인증 프로토콜은 두 통신 관계자가 어떤 다른 프로토콜(예) 신뢰적인 데이터 전송 프로토콜, 라우팅 정보 교환 프로토콜, 전자메일 프로토콜)을 수행하기 이전에 수행
   - 인증 프로토콜은 먼저 서로의 요구에 맞춰 통신 당사자들의 신원을 확인하며, 인증 후에야 통신 당사자들은 실제 작업을 시작할 수 있음

3. 신뢰적인 데이터 전송(Reliable Data Transfer, RDT) 프로토콜의 경우처럼 AP(Authentication Protocol)라 부르는 여러 가지 버전의 인증 프로토콜 고안

-----
### 인증 프로토콜 ap2.0
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/92c5dbea-bf3b-4c8e-9fa7-df4bfedb2bfd">
</div>

1. 앨리스가 항상 이미 알려진 네트워크 주소(예) IP 주소)를 가지고 통신을 한다면, 밥은 인증 메세지를 가지고 온 IP 데이터그램 출발지 주소가 앨리스의 주소와 동일한지 확인함으로써 앨리스를 인증할 수 있으며, 이 경우 앨리스는 인증을 받게 됨
2. 네트우크와 데이터 링크 계층에서 IP 데이터그램을 생성해 원하는 임의의 출발지 IP 주소를 넣고 데이터그램을 링크 계층 프로토콜을 통해 첫 번째 홉 라우터에 보내는 것은 어렵지 않음
   - 가짜 출발지 주소를 갖고 있는 데이터그램을 전송하는 방법은 IP 스푸핑(Spoofing)의 한 형태
   - 만약, 첫 번째 홉 라우터가 트루디의 IP 출발지 주소를 갖고 있는 데이터그램만을 전달하도록 설정되면 IP 스푸핑은 피할 수 있음
   - 하지만, 이런 기능은 보편적으로 사용되지 않고, 강제할 수 없음

-----
### 인증 프로토콜 ap3.0
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/6675e654-c3ca-4bcb-b5b7-d50cce835487">
</div>

1. 인증을 위한 고전적인 방식으로는 비밀번호를 사용
   - 비밀번호는 인증자와 인증 받는 사람 간의 공유된 비밀로, 많은 서비스에서 비밀번호 인증 사용

2. 그러나 통신을 도청하면 비밀번호를 쉽게 알아낼 수 있음

-----
### 인증 프로토콜 ap3.1
-----
1. ap3.0을 개선하기 위해 비밀번호를 암호화하는 것
   - 비밀번호를 암호화함으로써 비밀번호를 알아내는 것을 막을 수 있음
   - 앨리스와 밥이 대칭 비밀키 $K_{A-B}$를 공유한다고 가정한다면, 앨리스는 비밀번호를 암호화해서 그녀의 식별 메세지와 함께 암호화된 비밀번호를 밥에게 보낼 것
   - 밥은 다시 비밀번호를 복호화해서 비밀번호가 옳으면 앨리스를 인증
   - 밥은 앨리스가 그녀의 비밀번호와 그것을 암호화하는 데 필요한 공유 비밀키를 알고 있으므로 앨리스를 인증하는 데 문제가 없음

2. ap3.1이 트루디가 앨리스의 비밀번호를 알아내는 것을 막을 수 있는 건 사실이지만, 암호화 기술 사용이 인증 문제를 해결하지 못함
   - 밥은 재생 공격(Playback Attack) 위험에 노출되어 있음
   - 트루디는 앨리스의 통신을 도청하여 암호화된 비밀번호를 저장했다가 나중에 앨리스인것 처럼 밥에게 비밀번호의 암호화된 버전을 보냄

-----
### 인증 프로토콜 ap4.0
-----
1. 밥이 앨리스가 보낸 원래 인증 요청 메세지와 이를 이후 재생한 메세지를 구별하지 못하는 문제
   - 즉, 밥은 앨리스와의 통신이 라이브인지(실제로 연결의 다른 끝에 앨리스가 현재 있는 것인지) 아니면 이전 앨리스의 인증 요청을 재생한 것을 받고 있는지 구별할 수 없음

2. 해결 방법 : 3-Way TCP Handshake 프로토콜 사용
   - TCP 서버는 자신이 받은 SYN 세그먼트가 이전 연결 SYN 세그먼트의 복사본(재전송)이라면 연결을 수락하지 않음
   - 서버는 오랫동안 사용되지 않은 초기 순서 번호를 선택해서 클라이언트에게 번호를 보내고, 클라이언트는 이 번호를 담은 ACK 세그먼트로 응답하기를 기다림
   - 이를 인증 목적으로 사용

3. 넌스(Nonce) : 프로토콜이 평생에 단 한번만 사용하는 숫자를 의미
   - 즉, 프로토콜이 한 번 어떤 넌스를 사용하면, 이 숫자를 절대로 다시 사용하지 않음

4. 넌스 활용
<div align="center">
<img src="https://github.com/user-attachments/assets/44e5c008-3916-4569-8901-586a55be0da5">
</div>

   - 앨리스는 메세지 "나는 앨리스다"를 밥에게 보냄
   - 밥은 넌스 R을 선택하고 그것을 앨리스에게 보냄
   - 앨리스는 앨리스와 밥의 대칭 비밀키인 $K_{A-B}$를 사용해서 그 넌스를 암호화하고, 암호화된 넌스 $K_{A-B}(R)$를 밥에게 보냄
     + 프로토콜 ap3.1처럼 상대방이 $K_{A-B}$를 알고 있고 이를 암호화에 사용했으므로 밥은 자신이 받은 메세지를 앨리스가 만들었다는 사실을 알게 됨
     + 앨리스가 현재 실제 통신 중임을 확인하기 위해 넌스 사용
   - 밥은 자신이 받은 메세지를 복호화하며, 만약, 복호화된 넌스가 자신이 앨리스에게 보낸 것과 같다면 앨리스를 인증
   - 즉, 일회용인 R을 사용하고 반환되는 것 $K_{A-B}(R)$을 확인함으로써 밥은 스스로 앨리스라고 주장하는 사람이 진짜 앨리스라는 것(R의 암호화에 필요한 비밀키를 알고 있으므로) 실제로 현재 통신 중(밥이 방금 만든 넌스 R을 그녀가 암호화했으므로) 두 가지 확인 가능

5. 넌스와 대칭키 암호의 사용이 인증 프로토콜 ap4.0의 기초를 이룸
