-----
### 출력 포트 처리
-----
1. 출력 포트 메모리에 저장된 패킷을 가져와 출력 링크를 통해 전송
2. 전송을 위한 패킷 선택(즉, 스케줄링) 및 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능을 수행하는 것 포함

-----
### 큐잉 발생
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/a338243b-c7fc-473b-83f6-f7c03be23dde">
</div>

1. 패킷 큐는 입력 포트와 출력 포트 모두에서 형성 가능
   - 큐의 위치와 범위(입력 포트 큐 또는 출력 포트 큐)는 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라 달라짐
   - 큐가 커지면 라우터는 메모리가 결국 소모될 수 있고 도착하는 패킷을 저장할 수 있는 메모리가 없을 때 패킷 손실(Packet Loss)이 발생
   - 즉, 패킷이 네트워크 내에서 손실되거나 라우터에서 감소 : 라우터 내 패킷이 실제로 삭제되고 손실되는 큐에 있음

2. 입력 및 출력 라인의 속도(전송률)는 모두 초당 $R_{line}$ 패킷으로 동일한 전송을 갖고 있고, N개의 입력 포트와 N개의 출력 포트가 있다고 가정
   - 단순화를 위해 모든 패킷이 고정 길이가 같고 패킷이 동기식으로 입력 포트에 도착한다고 가정
   - 즉, 임의의 링크 상 패킷을 송신하는 시간은 임의의 링크상에서 패킷을 수신하는 시간과 동일하고, 그러한 시간 간격 동안 0 또는 하나의 패킷이 입력 링크상 도착할 수 있음
   - 패킷이 입력 포트에서 출력 포트로 이동할 수 있는 속도로 스위치 구조 전송률 $R_{switch}$로 정의
   - 만약, $R_{switch}$가 $R_{line}$ 보다 N배 빠르다면, 입력 포트에서 발생하는 큐잉은 무시 가능 (이는 최악의 경우에도 모든 N 입력 라인이 패킷들을 수신하고 모든 패킷이 같은 출력 포트에 전달되는 곳에서 N 패킷들(입력 포트당 1개의 패킷)의 배치 작업은 다음 배치 작업이 도착하기 전 스위치 구조를 통해 삭제될 수 있기 때문임)

-----
### 입력 큐잉
-----
1. 지연 없이 구조를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 입력 라인 속도에 비해 충분히 빠르지 않은 경우
   - 패킷이 스위치 구조를 통해 출력 포트로 전송되기 위해 차례를 기다려야 함
   - 크로스바 스위치 구조로 가정
     + 모든 링크 속도는 같음
     + 입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달
     + FCFS 방식으로 패킷은 입력 큐에서 출력 큐로 이동됨
     + 출력 포트가 다르다면 여러 패킷이 병렬로 전달될 수 있지만, 두 패킷이 같은 출력 큐로 향한다면 이 중 한 패킷은 차단되고 입력 큐에서 기다려야 함
     + 즉, 스위치 구조는 한 번에 하나의 패킷만 지정된 출력 포트로 전송 가능

2. 입력 큐 앞쪽에 있는 2개의 패킷이 동일한 오른쪽 상단의 출력 포트로 보내지는 예
<div align="center">
<img src="https://github.com/user-attachments/assets/b85bfbe3-0bbc-4917-8662-20e77b61a203">
</div>

   - 스위치 구조가 왼쪽 상단 큐의 앞쪽으로 패킷을 전송한다고 가정
   - 이 경우, 왼쪽 하단 큐에 짙은 색으로 처리된 두 번쨰 패킷은 대기해야 함
   - 아래쪽 밝은 패킷은 이동하려는 출력 링크(패킷의 목적지)가 경쟁이 없는 상태이지만 바로 앞 검정 패킷 때문에 기다려야 함
   - 이 현상은 입력 대기 중인 스위치에서의 HOL(Head-Of-the-Line) 차단(블로킹)이라고 하며, 라인의 앞쪽에서 다른 패킷이 막고 있으므로 입력 큐에서 대기 중인 패킷은 사용할 출력 포트가 사용 중이지 않아도 스위치 구조를 통해 전송되기 위해 기다려야 함
   - 입력 링크에서 패킷 도착 속도가 용량의 58%가 되면, HOL 차단 때문에 입력 큐가 무한정 길이로 증가하여 중요 패킷이 손실되는 패킷 손실이 증가

3. 출력 큐잉의 예
   - 스위치 출력 포트에서도 큐잉이 발생할 수 있는데, 먼저 R 스위치가 다시 $R_{line}$보다 N배 빠르며, N개의 입력 포트 각각에 도착하는 패킷이 동일한 출력 포트로 향하는 것으로 가정
     + 이 경우, 출력 링크에 단일 패킷을 보내는데 걸리는 시간에 N개의 새로운 패킷이 출력 포트(N개의 입력 포트 각각 하나씩)에 도착
     + 출력 포트는 시간 단위(패킷 전송 시간)에 단일 패킷만 전송할 수 있으므로 N개의 도착 패킷은 출력 링크를 통한 전송 큐에서 대기해야 함
     + 그러면, 대기 중인 N개의 패킷 중에서 하나를 전송할 때 다시 N개의 새로운 패킷이 도착할 수 있으므로, 스위치 구조가 포트 라인 속도보다 N배 빠른 경우에도 패킷 큐잉이 출력 포트에서 발생 가능
     + 결국, 대기 중인 패킷 수가 출력 포트에서 사용 가능한 메모리를 다 소모할 만큼 충분히 많아질 수 있음

   - 들어오는 패킷을 저장할 메모리가 충분하지 않을 때 도착한 패킷을 삭제(Drop-tail 정책)하거나 이미 대기 중인 하나 이상의 패킷을 제거해 새로 도착한 패킷을 저장하기 위한 공간을 확보해야 함
   - 어떤 경우에는 버퍼가 가득 차기 전 패킷을 삭제(또는 헤더 마킹)하여 송신자에게 혼잡 신호를 제공하는 것이 바람직할 수 있음
   - 또는, 명시적 혼잡 알림(ECN) 비트 사용, AQM(Active Queue Management) 알고리즘으로 알려진 많은 패킷 삭제와 패킷 마킹 정책이 제안되거나 분석되고 있음
   - 가장 폭넓게 연구되고 구현된 AQM 알고리즘 중 하나는 RED(Random Early Detection)이며, 좀 더 최근 AQM 정책에는 PIE(Proportional Integral Controller Enhanced) 및 CoDel이 포함

   - 출력 포트 큐잉
<div align="center">
<img src="https://github.com/user-attachments/assets/0b0fae78-f4cb-4222-99f1-1e0bbca4e8a1">
</div>

   - 시각 t에서 패킷은 각 입력 포트에 도달하고 각 포트는 맨 앞의 출력 포트로 향함
   - 동일한 라인 속도를 가지고, 라인 속도의 3배(즉, 패킷을 수신 또는 전송하는데 필요 시간)로 동작하는 것으로 가정
   - 기존의 패킷 3개가 모두 출력 포트로 전송되어 대기 중
   - 이 3개 패킷 중 하나는 다음 번 출력 라인을 통해 전송될 것
   - 2개의 새로운 패킷이 수신 측에 도착했고, 이 패킷 중 하나는 맨 앞 출력 포트로 전송
   - 이러한 큐잉의 결과는 출력 포트의 패킷 스케줄러(Packet Schedular)가 전송 대기 중인 패킷 중 하나의 패킷을 선택해야 함
