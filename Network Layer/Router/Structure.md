-----
### 라우터 구조
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/e698f50a-1093-4d25-b0b5-5562a7eebd6b">
</div>

1. 입력 포트 (포트 : 물리적인 입출력 라우터 인터페이스로 네트워크 애플리케이션 및 소켓과 관련된 소프트웨어 포트와는 다른 것)
   - 입력 포트의 맨 왼쪽 박스와 출력 포트의 맨 오른쪽 박스는 라우터로 들어오는 입력 링크로 물리 계층 기능 수행
   - 입력 포트는 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능 수행 (입력 및 출력에서 미들박스로 표기)
   - 입력 포트에서 검색 기능 수행 : 가장 오른쪽 박스에서 발생
     + 포워딩 테이블을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정
   - 제어 패킷(예) 라우팅 프로토콜 정보로 전달하는 패킷)은 입력 포트에서 라우팅 프로세서로 전달

2. 라우터가 지원하는 포트의 수는 비교적 적은 수의 기업 라우터에서 수백 개의 10 Gbps 포트를 갖는 ISP 가장 자리 라우터까지 다양하며, 라우터의 입력 라인 수는 많아지는 경향이 있음
3. 스위치 구조 : 라우터의 입력 포트와 출력포트를 연결하며, 스위치 구조는 라우터 내부에 포함(네트워크 라우터의 내부 네트워크)
4. 출력 포트
   + 스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷 전송
   + 링크가 양방향 인 경우(즉, 양방향으로 트래픽 전달), 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룸
5. 라우팅 프로세서 : 제어 평면 기능 수행
   - 기존 라우터에서는 라우팅 프로토콜을 실행하고, 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블 계산
   - SDN 라우터에서 라우팅 프로세스는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 입력 포트에 이러한 엔트리를 설치
   - 또한, 네트워크 관리 기능 수행

6. 라우터의 입력 포트, 출력 포트, 스위치 구조는 거의 항상 하드웨어로 구현
   - 100 Gbps 입력 링크와 64 바이트 IP 데이터그램이 있는 경우, 입력 포트는 다른 데이터그램이 도착하기 전 데이터그램을 처리하는데 5.12 ns만을 갖는다고 생각
   - 만약 N 포트가 라인 카드에서 결합되는 경우, 데이터그램 처리 파이프라인은 소프트웨어 구현에 대해 N배 더 빠르게 작동해야 함

7. 데이터 평면이 나노초(ns) 단위로 작동하는 동안, 라우터의 제어 기능은(라우팅 프로토콜 실행, 원격 컨트롤러와 통신(SDN의 경우) 및 관리 기능 수행) 밀리초(ms) 또는 2초 단위로 작동
   - 제어 평면 기능은 일반적으로 소프트웨어로 구현되며, 라우팅 프로세서에서 실행
  
-----
### 입력 포트 처리 및 목적지 기반 전송
-----
1. 입력 처리 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/e0133c73-e04a-4e2c-82ea-96e3d5457da9">
</div>

  - 입력 포트의 라인 종단 기능과 링크 처리 계층 처리는 라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층을 구현
  - 입력 포트에서 수행되는 검색은 라우터 동작의 핵심
  - 라우터는 포워딩 테이블을 사용해 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색
  - 포워딩 테이블은 라우팅 프로세서(다른 네트워크 라우터와 라우팅 프로세서와 상호작용을 위해 라우팅 프로토콜 사용)에서 계산되거나 갱신되거나 원격 SDN 컨트롤러에서 수신
    + 포워딩 테이블은 라우팅 프로세서에 입력 라인 카드로 복사
    + 각 라인 카드에서 이와 같은 섀도 복사본을 사용하면 패킷 단위로 중앙 집중식 라우팅 프로세서를 호출하지 않게 되고, 병목 현상을 피할 수 있음

2. 입력 패킷을 스위칭할 출력 포트가 각 패킷의 목적지 주소를 기반으로 하는 가장 간단한 경우
   - 32비트 IP 주소의 경우, 포워딩 테이블을 억지로 구현한다면 모든 가능한 목적지 주소마다 하나의 엔트리가 필요하므로, 40억 개 이상 가능한 주소가 있어야 하므로 불가능
   - 라우터 0에서 3까지의 4개의 링크가 있으며, 다음과 같이 링크 인터페이스로 전달한다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/62774a3f-474c-4671-a155-bb80ad0a10a9">
</div>

   - 4개의 엔트리를 갖는 포워딩 테이블이면 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/50a8c3b4-ca72-45b6-9cd7-0ef633737b91">
</div>

   - 포워딩 테이블에서 라우터는 패킷의 목적지 주소의 프리픽스(Prefix)를 테이블의 엔트리와 매치하며, 매치되는 엔트리가 존재하면 라우터는 패킷을 그 매치에 연관된 링크로 보냄
   - 예시) 패킷의 목적지 주소가 11001000 00010111 00010110 10100001이라고 가정
     + 주소의 앞 21개 비트 프리픽스가 테이블의 첫 번쨰 엔트롸 일치하므로 라우터는 이 패킷을 링크 인터페이스 0으로 보냄
     + 만약, 앞 3개와 엔트리와 매치되지 않으면 라우터는 패킷을 고정 인터페이스 3으로 보냄
   - 예시) 목적지 주소가 엔트리 이상에 매치될 수 있는 가능성 : 주소 11001000 0001011 00011000 10101010
     + 처음 24비트는 테이블에 있는 두 번쨰 엔트리에 매치
     + 주소의 처음 21비트는 테이블에 있는 세 번째 엔트리에 매치
   - 💡 다수의 매치가 있을 때는 라우터는 최장 프리픽스 매치 규칙(Longest Prefix Matching Rule) 사용
     + 즉, 테이블에서 가장 긴 매치 엔트리를 찾고, 여기에 관련된 링크 인터페이스로 패킷을 보냄

3. 포워딩 테이블의 검색
   - 하드웨어 로직은 포워딩 테이블을 검색해서 가장 긴 프리픽스와 매치되는 것을 찾음
   - 그러나 기가바이트 전송률에서 이 검색은 나노초 단위로 수행되어야 함
   - 따라서, 하드웨어에서 검색해야 할 뿐만 아니라 대형 테이블을 통한 단순 선형 검색 이외 기술 필요
   - 메모리 접속 시간에 특별히 주의를 기울여야 하므로 내장형 DRAM과 빠른 SRAM(DRAM 캐시로 사용) 메모리가 있는 설계 필요
      + 실제, TCAM(Ternary Content Addressable Memory)도 검색을 위해 자주 사용되며, 이를 사용하면 32비트 IP 주소가 메모리에 제공
      + 이 주소는 본질적으로 일정 시간 동안 해당 주소에 대한 포워딩 테이블 엔트리 내용 반환
   - 검색을 통해 패킷 출력 포트가 결정되면 패킷을 스위치 구조로 보낼 수 있음
     + 일부 설계에서는 다른 입력포트로부터 패킷이 현재 구조를 사용하고 있다면, 패킷이 스위칭 구조에 들어가는 것 일시적 차단 가능
     + 차단된 패킷은 입력 포트에 대기한 다음, 나중에 구조를 교체하도록 예약

4. 그 밖의 기능
   - 물리 및 링크 계층 처리
   - 패킷의 버전 번호, 체크섬, TTL(Time-To-Live) 필드를 확인하고 이후 두 필드를 다시 사용
   - 네트워크 관리에 사용되는 카운터(수신된 IP 데이터그램 수) 갱신

5. 정리
   - 목적지 IP 주소를 찾은(매치) 다음, 패킷의 스위치 구조로 지정된 출력 포트로 전송(액션)하는 것은 라우터뿐만 아니라 많은 네트워크 장치에서 수행되는 일반적인 매치 플러스 액션(Match Plus Action)
