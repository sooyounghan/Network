-----
### 인터넷 프로토콜 버전 4 (IPv4)
-----
1. 데이터그램(Datagram) : 인터넷 네트워크 계층 패킷
2. IPv4 데이터그램 포맷
<div align="center">
<img src="https://github.com/user-attachments/assets/fb8af04c-965b-4ef0-b8bd-a69f5286e5da">
</div>

  - 버전 번호 : 4비트로 데이터그램의 IP 프로토콜 버전 명시
    + 라우터는 버전 번호를 확인 해 데이터그램의 나머지 부분을 어떻게 해석할지 결정
    + 다른 버전의 IP는 다른 데이터그램 포맷 사용
   
  - 헤더 길이 : IPv4 데이터그램은 헤더에 가변 길이 옵션을 포함하므로 IP 데이터그램에서 실제 페이로드(예를 들어, 데이터그램에 캡슐화된 트랜스포트 세그먼트)가 시작하는 곳을 결정
    + 대부분 IPv4 데이터그램은 옵션을 포함하지 않으므로 대체로 IPv4 데이터그램 헤더는 20바이트

  - 서비스 타입 : IPv4 헤더에 포함된 서비스 타입(TOS, Type Of Service) 비트는 각기 다른 유형의 IP 데이터그램 구별
    + 예를 들어, 실시간 데이터 그램(IP 전화 통신 애플리케이션)과 비실시간 트래픽(예) FTP)을 구분하는데 유용
    + 제공될 특정 서비스 레벨은 해당 라우터의 네트워크 관리자가 결정하고 구성할 정책 문제
    + TOS 비트 중 2개는 명시적 혼잡 알림에 사용

  - 데이터그램 길이 : 바이트로 계산된 IP 데이터그램(헤더와 데이터)의 전체 길이
    + 필드의 크기는 16비트이므로 IP 데이터그램 이론상 최대 길이는 65536 바이트이지만, 1500바이트보다 큰 경우는 거의 없음
    + 최대 크기의 이더넷 프레임 페이로드 필드에 IP 데이터그램 장착 가능

  - 식별자, 플래그, 단편화 오프셋 : IP 단편화와 관련
    + 큰 IP 데이터그램이 여러 개 작은 IP 데이터그램으로 분할된 다음 목적지로 독립적으로 전달되며, 여기서 페이로드 데이터가 최종 호스트의 트랜스포트로 전달되기 전 다시 모이게 됨
    + IPv6은 단편화를 허용하지 않음

  - TTL(Time-To-Live) : 네트워크에서 데이터그램이 무한히 순환하지 않도록 함(라우팅 루프)
    + 라우터가 데이터그램을 처리할 떄마다 감소
    + 필드가 0이 되면 라우터가 데이터그램 폐기

  - 프로토콜 : IP 데이터그램이 최종 목적지에 도착했을때만 사용
    + 이 필드값은 IP 데이터그램에서 데이터부분이 전달될 목적지의 트랜스포트 계층의 특정 프로토콜 명시
    + 예) 값 6은 데이터 부분을 TCP로, 값 17은 UDP로 전달하라는 뜻
    + IP 데이터그램에서 프로토콜 번호 역할은 트랜스포트 게층 세그먼트에서 포트 번호 역할과 유사

  - 헤더 체크섬 : 라우터가 수신한 IP 데이터 그램의 비트 오류를 탐지하는데 도움
    + 헤더에서 각 2바이트를 수로 처리하고 이 1의 보수를 합산하여 계산
    + 인터넷 체크섬으로 알려진 이 합의 1의 보수는 체크섬 필드에 저장
    + 라우터는 수신한 각 IP 데이터그램마다 헤더 체크섬을 계산하고 이 값을 데이터그램 헤더의 체크섬과 다르면 오류 상태임을 감지
    + 라우터는 보통 오류가 검출된 데이터그램을 폐기 : TTL 필드와 옵션 필드의 값이 변경되므로 체크섬은 각 라우터에서 재계산되고 저장되어야 함
    + IP 헤더만 IP 계층에서 체크섬을 수행, TCP/UDP 체크섬은 전체 TDP/UDP 세그먼트를 계산하며, TCP/UDP와 IP는 동일한 프로토콜 스택에 속할 필요가 없음 (원리상 TCP는 IP가 아닌 다른 네트워크 프로토콜 위에서 운영될 수 있고, IP는 TCP/UDP로 전달되지 않는 데이터를 전달할 수 있음)

  - 출발지와 목적지 IP 주소
    + 출발지가 데이터그램을 생성할 때, 자신의 IP 주소를 출발지 IP 주소 필드에 삽입하고, 목적지 IP 주소를 목적지 IP 주소 필드에 삽입
    + 종종 출발지 호스트는 DNS 검색을 통해 목적지 주소를 결정할 수 있음

  - 옵션 : IP 헤더 확장
    + 모든 데이터그램 헤더 옵션 필드에 정보를 포함하지 않는 방법으로, 오버헤드를 해결하기 위해 헤더 옵션을 거의 사용하지 않음
    + 데이터그램 헤더가 가변 길이로 데이터 필드 시작점을 초기에 결정할 수 없어 옵션은 문제를 더 복잡하게 만듬
    + 일부 데이터그램은 옵션 처리 유무에 따라 라우터에서 IP 데이터그램을 처리하는데 필요한 시간이 크게 달라지므로, 이런 가변 길이 옵션은 고성능 라우터 및 호스트에서 IP 처리에 특히 중요 (따라서, IPv6에서 IP 옵션 미 포함)

  - 데이터(페이로드)
    + IP 데이터그램의 데이터 필드는 목적지에 전달하기 위해 트랜스포트 계층 세그먼트(TCP / UDP)를 포함하지만 ICMP 메세지 같은 유형의 데이터를 담기도 함

3. IP 데이터 그램은 총 20바이트의 헤더(옵션 없다고 가정)를 가지며, 데이터그램이 TCP 세그먼트를 전송한다면 단편화가 되지 않은 각 데이터그램은 애플리케이션 계층 메세지와 더불어 총 40바이트 헤더(IP 헤더 20바이트 + TCP 헤더 20바이트) 전송

-----
### IPv4 주소 체계
-----
1. 호스트는 일반적으로 네트워크와 연결되는 하나의 링크를 가지며, 호스트 IP가 데이터그램을 보낼 때 이 링크를 통해 데이터링크를 보냄
2. 인터페이스 (Interface) : 호스트와 물리적 링크 사이 경계
   - 라우터의 작업은 한 링크로부터 데이터그램을 수신하여 다른 링크로 전달하는 것이므로 라우터는 2개 이상의 연결된 링크 필요
   - 라우터와 이런 링크 사이 경계 또한 인터페이스라고 하며, 각 링크마다 하나의 인터페이스를 갖고 하나의 라우터는 여러 개의 인터페이스를 가짐
   - 모든 호스트와 라우터는 IP 데이터그램을 송/수신할 수 있으므로 IP는 각 호스트와 라우터 인터페이스가 IP 주소를 갖도록 요구
   - 💡 기술면에서 IP 주소는 인터페이스를 포함하는 호스트 라우터보다 인터페이스와 관련이 있음

3. 각 IP 주소는 32비트 길이(4바이트)
   - 따라서, $2^{32}$개(대략 40억개)의 주소를 사용할 수 있음
   - 일반적으로 주소의 각 바이트를 십진수로 표현하고, 주소의 다른 바이트와 점(.)으로 구분하는 십진 표기법 사용
   - 예) IP 주소가 ```193.32.216.9``` : 193은 주소의 첫 번째 8개 비트이며, 32는 주소의 두 번째 8개 비트와 같으므로, 이 주소를 이진수로 나타내면 다음과 같음
```
11000001 00100000 11011000 00001001
```
   - 전 세계 인터넷에서 모든 호스트와 라우터의 각 인터페이스는 고유한 IP 주소를 가짐
   - 인터페이스와 IP 주소 일부는 연결된 서브넷이 결정

4. IP 주소 체계와 인터페이스의 예
<div align="center">
<img src="https://github.com/user-attachments/assets/e3be2016-1dc2-40ed-be0a-f6600df6ab96">
</div>

   - 3개의 인터페이스를 갖는 하나의 라우터는 7개의 호스트를 연결하며, 호스트와 라우터 인터페이스에 할당된 IP 주소는 다음과 같음
     + 왼쪽 3개 호스트와 연결된 라우터 인터페이스는 모두 ```223.1.1.xxx``` 형식의 IP 주소를 가짐 : 동일한 왼쪽 24비트를 사용
     + 또한, 4개의 인터페이스가 중계하는 라우터없이 하나의 네트워크에 서로 연결
     + 이 네트워크는 이더넷 LAN으로 상호연결되고 이 경우 인터페이스는 이더넷 허브나 이더넷 스위치 또는 무선 AP로 상호연결
     + 호스트들이 연결된 경로가 없는 네트워크를 구름으로 나타냄

5. 서브넷(Subnet) : IP 용어로 위 세 호스트들이 인터페이스들과 하나의 라우터 인터페이스로 연결된 네트워크는 서브넷을 구성한다고 말함
   - 서브넷은 인터넷 문서에서 IP 네트워크 또는 간단히 네트워크라고 함
   - IP 주소 체계에서 이 서브넷에 ```223.1.1.0/24```이라는 주소 할당 : /24는 서브넷 마스크(Subnet Mask)를 의미하며, 32비트 주소의 왼쪽 24비트가 서브넷 주소임을 의미
     + 세 호스트 인터페이스(```223.1.1.1, 223.1.1.2, 223.1.1.3111```)와 하나의 라우터 인터페이스(```223.1.1.4```)를 구성
     + 네트워크 ```223.1.1.0/24```에 새로 부착할 호스트에는 ```223.1.1.xxx``` 형식의 주소가 필요
   - 이 외에도 2개의 서브넷(```223.1.2.0/24, 223.1.3.0/24``` 네트워크) 존재

<div align="center">
<img src="https://github.com/user-attachments/assets/d369c5a8-fb76-4b4f-af16-3c2e32596de2">
</div>

   - 서브넷의 IP 정의는 여러 호스트를 라우터 인터페이스에 연결하는 이더넷 세그먼트만 의미하는 것이 아님
   - 3개의 라우터가 점대점으로 연결된 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/ff982d77-f1e2-4775-99b3-8ed300112d17">
</div>

  - 각 라우터는 각 점대점 링크를 위해 2개, 두 호스트를 직접 연결하는 브로드캐스트 링크를 위해 1개, 모두 3개의 인터페이스를 가짐
  - 3개의 서브넷 ```223.1.1.0/24, 223.1.2.0/24, 223.1.3.0/24```는 세 서브넷 라우터 R1, R2를 연결하는 인터페이스용으로 ```223.1.9.0/24``` 서브넷, 그리고 R2와 R3를 연결하는 인터페이스용  ```223.1.8.0/24``` 서브넷, 그리고 R2와 R3를 연결하는 인터페이스용  ```223.1.7.0/24``` 서브넷이 추가
  - 💡 서브넷을 결정하려면 먼저 호스트나 라우터에서 각 인터페이스를 분리하고, 고립된 네트워크를 만듬
    + 이 고립된 네트워크의 종단점은 인터페이스의 끝이 되며, 고립된 네트워크 각각을 서브넷이라고 부름
    + 위의 그림에서 총 6개의 고립된 서브넷을 얻음

  - 다수의 이더넷 세그먼트와 종단 간 링크를 갖는 기관(학교, 회사 등)은 한 서브넷에서 모든 장비가 같은 서브넷 주소를 갖는 그런 서브넷을 여러 개 가질 수 있음
    + 원칙적으로는 서로 다른 서브넷은 다른 서브넷 주소를 가져야 하지만, 실제로 서브넷 주소는 종종 같은 부분이 많음

6. CIDR (Classless InterDomain Routing, 사이다(CIDER)
   - 서브넷 주소체계 표기를 일반화하는 것
   - 서브넷 주소 체계로서, 32비트 IP 주소는 두 부분으로 나누고, 이를 다시 점으로 된 십진수 형태의 ```a.b.c.d/x```를 가지며, x는 주소 첫 부분의 비트 수
   - ```a.b.c.d/x``` 형식 주소에서 최상위 비트(Most Significant Bit, MSB)를 의미하는 x는 IP 주소의 네트워크 부분을 구성하며, 이를 해당 주소의 프리픽스(Prefix), 또는 네트워크 프리픽스라고 부름
   - 한 기관은 통상 연속적인(공통 프리픽스를 갖는 주소 범위) 주소 블록을 할당 받음 : 이 경우, 기관 장비들의 IP 주소는 공통 프리픽스를 공유
   - BGP 라우팅 프로토콜에서는 앞의 프리픽스 x가 해당 기관 네트워크 외부의 라우터에 의해 고려됨 (즉, 외부 기관의 라우터는 목적지 주소가 내부 기관인 데이터그램을 전달할 때, 단지 앞의 x비트들만 고려)
     + ```a.b.c.d/x``` 형태의 한 엔트리만 기관 목적지로 패킷을 전달하는데 충분하므로, 라우터들에서 포워딩 테이블 크기를 상당히 줄여줌
   - 주소의 나머지 32 - x 비트들은 기관 내부에 같은 네트워크 프리픽스를 갖는 모든 장비를 구별
     + 이 비티들은 기관 내부 라우터에서 패킷을 전달할 때 사용
     + 이 하위 비트들은 추가 서브넷 구조를 가질 수 있음

   - 예) CIDR식 주소 ```a.b.c.d/21```의 첫 21비트들은 기관의 네트워크 프리픽스를 나타내고, 이 기관의 모든 장비에 IP 주소가 공통이라고 가정
     + 나머지 11비트들은 기관 내부 특정 호스트들을 식별
     + 기관 내부 구조가 이 최하위 11비트들 중 일부를 기관 내부의 서브넷을 위해 사용할 수 있음
     + 예를 들어, ```a.b.c.d/24```는 기관 내부의 특정 서브넷을 나타낼 수 있음

   - CIDR가 채택되기 전까지 IP 주소 네트워크 부분을 8, 16, 24비트로 제한했고, 이를 각각 A, B, C 클래스 네트워크로 분류 : 클래스 주소체계(Classful Addressing)
     + 그러나 IP 주소의 서브넷 부분이 정확히 1, 2, 3바이트여야 한다는 요구사항은 중소형 크기 네트워크로 급속히 증가하는 기관 수를 지원하기에는 문제 발생
     + 클래스(/24) 서브넷은 $2^{8} - 2 = 254$개($2^{8} = 256$개 주소에서 2개는 특별한 사용을 위해 예약)의 호스트만을 제공하므로 턱없이 부족하며, 반면 65634개 호스트를 제공하는 B 클래스(/16) 서브넷은 너무 큼
     + 클래스 주소 체계에서 2000개 호스트가 있는 조직은 일반적으로 B 클래스 서브넷 주소에 할당하지만, 이는 B 클래스 주소 공간을 빨리 고갈시키고 주소 할당에 있어 형편없는 효율성 초래
     + 즉, 남은 63000개 이상의 주소를 사용하지 않더라도 다른 조직이 사용할 수 없음

7. CIDR 주소를 이용하여 계층적인 라우터 처리 예시
   - ISP가 8개 조직을 큰 인터넷으로 연결하는 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/b4a91d47-0bc6-421e-b5a5-2ef2f706f502">
</div>

   - ISP(Fly-BY-Night-ISP)가 주소 첫 20비트가 ```200.23.16.9/20```과 같은 데이터그램을 보내는 것을 외부에 알린다고 가정
   - 주소 블록 ```200.23.16.9/20```에 자체 서브넷을 갖는 8개 조직이 있다는 것을 외부에서는 알 필요가 없음
     + 따라서, 여러 네트워크를 알리기 위해 하나의 네트워크 프리픽스를 사용 : 경로/주소 집약(Route/Address Aggregation), 경로 요약(Route Summarization)
   - ISP가 주소를 블록으로 할당받고 이 주소를 클라이언트 조직에 할당할 때 경로 집약은 매우 잘 작동
   - 하지만, 이러한 계층 방식으로 할당하지 않을 경우 문제 발생
     + 이 ISP가 ISPs-R-Us를 인수한 후 조직 1이 자회사인 ISPs-R-Us를 통해 인터넷에 연결하면, ISPs-R-Us는 주소 블록 ```199.31.9.9/16```을 갖지만, 조직 1의 IP 주소는 이 주소 블록에 속하지 않음
     + 해결 방법으로는 조직 1은 ISPs-R-Us의 주소 블록 내 주소로 모든 라우터와 호스트 IP를 바꿀 수 있지만, 비용이 많이 들고 미래에 조직 1이 ISPs-R-Us에서 다른 ISP로 바꾸려 할 수 있음
     + 최선책으로는 조직 1이 ```200.23.18.0/23```로 IP 주소를 유지하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/c1df7322-f31a-4ed5-8026-64caf80cfaf1">
</div>

   - Fly-BY-Night-ISP는 계속해서 주소 블록 ```200.23.16.9/20```을, ISPs-R-Us는 ```199.31.9.9/16```을 광고
   - 💡 그리고 ISPs-R-Us는 조직 1에 대한 주소 블록 ```200.23.18.0/23```을 광고하여 더 큰 인터넷에서 다른 라우터가 Fly-BY-Night-ISP가 알린 주소 ```200.23.16.9/20```와 ISPs-R-Us에서 온 ```200.23.18.0/23``` 주소 블록을 보고  ```200.23.18.0/23``` 블록 안 주소로 라우팅할 때, 최장 프리픽스 매치를 사용해 목적지 주소와 매치되는 더 길고 상세한 주소 점유자를 알리는 ISPs-R-Us로 라우팅

9. 브로드 캐스트 주소
   - IP 주소의 또다 다른 형태로 ```255.255.255.255```가 존재
   - 호스트 목적지 주소가 ```255.255.255.255```인 데이터그램을 보내면, 이 메세지는 같은 서브넷에 있는 모든 호스트들에게 전달
   - 마찬가지로 라우터는 선택적으로 이웃 서브넷에 메세지를 전달
