-----
### 거리 벡터(DV) 라우팅 알고리즘
-----
1. 링크 상태 알고리즘이 네트워크 전체 정보를 이용하는 알고리즘인 반면, 거리 벡터(DV, Distance-Vector) 알고리즘은 반복적이고 비동기적이며 분산적
2. 각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 이웃들에게 배포한다는 점에서 분산적(Distributed)
3. 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다는 점에서 반복적(Iterative) (이 알고리즘은 자기 종료를 함(즉, 계산을 멈추라는 신호가 없어도 알아서 멈춤)
4. 모든 노드가 정확히 맞물려 동작할 필요가 없으므로 비동기적(Asynchronous)
5. 최소 비용 경로의 비용들 사이의 관계 - 벨만-포드(Bellman-Ford) 식에 의한 최소 비용 계산
   - 노드 x에서부터 y까지의 최소 비용 경로의 비용을 $d_{x}(y)$
<div align="center">
<img src="https://github.com/user-attachments/assets/7b23df6b-2e80-418c-af0e-04e1c356e457">
</div>

   - $min_{v}$는 x의 모든 이웃에 적용
   - x에서 v로 이동한 후, v에서 y까지 최소 비용 경로를 택한다면, 경로 비용은 c(x, y) + $d_{v}(y)$
   - 반드시 하나의 이웃 v로 가는 것부터 시작해야 하므로, x에서 y까지 최소 비용은 모든 이웃 노드 v에 대해 계산된 c(x, y) + $d_{v}(v)$ 중 최솟값
<div align="center">
<img src="https://github.com/user-attachments/assets/66c97c12-3236-490c-8654-09f85de5f1b5">
</div>

   - 출발지 노드 u는 노드 v, x, w라는 3개의 이웃을 가지며, 그래프에서 여러 경로들을 따라가보면 $d_{v}(z) = 5$, $d_{x}(z) = 3$, $d_{w}(z) = 3$
   - 이 값들을 c(u, v) = 2, c(u, x) = 1, c(u, w) = 5이므로, $d_{u}(z) = min(2 + 5, 5 + 3, 1 + 3)$을 얻게 되며, 이는 네트워크에 다익스트라 알고리즘을 적용해 얻은 결과와 정확히 일치

6. 벨만-포드 식의 해답은 각 노드 포워딩 테이블의 엔트리 제공
   - 위 식에서 최소로 만드는 이웃 노드를 $v^{*}$라고 가정
   - 이 때, 만약 노드 x가 노드 y에게 최소 비용 경로로 패킷을 보내기 원한다면, 노드 x는 패킷을 노드 $v^{*}$로 전달해야 함
   - 그러므로 노드 x의 포워딩 테이블에는 최종 목적지 y로 가기 위한 다음 홉 라우터로 $v^{*}$가 지정되어야 함
   - 즉, DV 알고리즘에서 일어나는 이웃 간 통신 형식을 제안
     + 예를 들어, 출발지 노드를 x라고 하면, 노드 x는 자신으로부터 집합 N에 속한 다른 모든 노드 y까지의 최소 비용 경로의 비용 $D_{x}(y)$를 추정
     + $D_{x} = [D_{x}(y) : y in N]$을 노드 x에서부터 N에 속한 모든 다른 노드 y까지의 비용 추정 값의 벡터라고 하면, DV 알고리즘으로 각 노드 x는 다음 라우팅 정보 유지
       * 각 이웃 노드 v 중 x에 직접 접속된 이웃 노드까지 비용 c(x, y)
       * 노드 x의 거리 벡터, 즉 x로부터 N에 있는 모든 목적지 y로의 비용 예측값을 포함하는 벡터 $D_{x} = [D_{x}(y) : y in N]$
       * 이웃 노드들의 거리 벡터들, 즉 v가 x의 이웃이라고 하면, $D_{v} = [D_{v}(y) : y in N]$

   - 분산적이고 비동기적으로 동작하는 알고리즘에서 각 노드가 자신의 거리 벡터를 때때로 이웃들에게 보냄
   - 노드 x가 이웃 w에게서 새로운 거리 벡터를 수신하면, x는 w의 거리 벡터를 저장하고 벨만-포드 식을 사용해 자신의 거리 벡터 갱신
<div align="center">
<img src="https://github.com/user-attachments/assets/8003f6d7-2465-45da-a26d-74eea6102e91">
</div>

   - 만약 이 갱신으로 인해 노드 x의 거리 벡터가 변경된다면, 노드 x는 이 수정된 거리 벡터를 자신의 이웃들에게 보내고, 그에 따라 이웃들도 자식의 거리 벡터 갱신
   - 모든 노드가 자신의 거리 벡터를 비동기적으로 교환하는 동작을 계속하게 되면, 비용 추정값 $D_{x}(y)$는 노드 x에서 노드 y까지의 실제 최소 비용 경로 비용인 $d_{x}(y)$로 수렴

-----
### 거리 벡터 (DV) 알고리즘
-----
1. 각 노드 x에서
<div align="center">
<img src="https://github.com/user-attachments/assets/5efd93fc-a487-4645-8817-48140b078a02">
</div>

2. DV 알고리즘에서는 어떤 노드 x가 자신에게 직접 연결된 링크 중 하나의 비용이 변경된 사실을 알게되거나 어떤 이웃으로부터 변경된 거리 벡터를 수신했을 때 자신의 거리 벡터 추정값을 계산
3. 💡 그러나 특정 목적지 y에 대한 자신의 포워딩 테이블을 갱신하기 위해 노드 x가 알아야 하는 것은 y까지의 최단 경로가 아닌 y로의 최단 경로상의 다음 홉 라우터인 이웃 노드 $v^{*}(y)$
   - 다음 홉 라우터는 $v^{*}(y)$는 DV 알고리즘 14번째 줄에서 최솟값을 갖게 하는 이웃 v (만약, 최솟값을 갖게 하는 여러 개 이웃이 있다면, 그 중 어느 것이든 될 수 있음)
   - 즉, 각 목적지 y에 대해 노드 x는 $v^{*}(y)$를 결정하고 목적지 y에 대해 포워딩 테이블도 갱신

4. LS 알고리즘은 다익스트라 알고리즘을 수행하기 전 각 노드가 네트워크에 대한 전체 지도를 먼저 얻어야 하므로 중앙 집중형 알고리즘이지만, DV는 분산적이고 그러한 전체 정보를 사용하지 않고 하나의 노드가 갖는 정보는 단지 자신에게 직접 연결된 이웃으로의 링크 비용과 그 이웃들로부터 수신하는 정보뿐임
   - 각 노드는 이웃으로부터 갱신을 기다림
   - 업데이터를 수신하면 새로 거리 벡터 계산
   - 이 새로운 거리 벡터를 이웃들에게 배포
   - DV의 유사 알고리즘은 실제 인터넷의 RIP, BGP, ISO IDRP, 최초 ARPAnet을 포함해 많은 라우팅 알고리즘에서 사용

5. 세 노드로 이루어진 단순한 네트워크의 거리 벡터 알고리즘 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/38e11189-acec-472d-af82-1f8e1c476268">
</div>

   - 알고리즘 동작은 동기적
   - 즉, 모든 노드가 동시에 이웃에게서 거리 벡터를 받고, 새로운 거리 벡터를 계산해서 변화가 있다면 그들의 이웃에게 알림
   - 그림의 가장 왼쪽 열 : 세 노드 각 최초의 라우팅 테이블 모습
     + 특정 라우팅 테이블에서 각 행은 거리 벡터
     + 구체적으로, 각 노드의 라우팅 테이블은 자신과 이웃들의 거리 벡터를 가짐
     + 그러므로 노드 x의 초기 라우팅 테이블 첫 번째 행은 $D_{x} = [D_{x}(x), D_{x}(y), D_{x}(z)] = [0, 2, 7]$
     + 두 번째, 세 번째 행은 각 노드 y와 z로부터 받은 가장 최근의 거리 벡터
     + 최초 노드 x가 y와 z로부터 받은 것이 아무것도 없으므로 이 엔트리들은 무한대로 초기화

   - 초기화 이후, 각 노드는 자신의 두 이웃에게 각 자신의 거리 벡터를 보냄
     + 이 과정은 첫 번째 열에서 두 번째 열로 가는 화살표로 표현
     + 노드 x는 자신의 거리 벡터 $D_{x} = [0, 2, 7]$를 노드 y와 노드 z에게 보냄
     + 갱신을 수신한 후 각 노드는 자신의 거리 벡터를 재계산
     + 노드 x는 다음을 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/99f5fa7f-df0b-49a4-94ec-958d96f347ce">
</div>

   - 각 노드 테이블의 두 번째 열은 이웃으로부터 방금 수신한 거리 벡터와 함께 노드의 새로운 거리 벡터를 보여줌
     + 예를 들어, 노드 x의 노드 z까지의 최소 비용 추정값 $D_{x}(z)$가 7에서 3으로 변경
     + 또한, 노드 x의 테이블에서 이웃 노드 y는 알고리즘의 14번째 줄이 최솟값이 되게 하는 노드로, 이 단계에서 노드 x에는 $v^{＊}(y) = y, v^{＊}(z) = y$가 기록
     
   - 노드들이 거리 벡터를 재계산한 후에, 만약 변화가 있다면 갱신된 거리 벡터를 다시 이웃들에게 보내며, 테이블의 두 번쨰 열에서 세 번째 열로 가는 화살표로 표현
     + 여기서는 노드 x와 z만이 거리 벡터 정보를 보냄 (노드 y의 거리 벡터는 변하지 않았으므로 노드 y는 거리 벡터 정보를 보내지 않음)
     + 새로운 거리 벡터 정보를 수신하면 세 번째 열에 보인대로 노드는 자신의 거리 벡터를 재계산하고 라우팅 테이블 갱신

   - 이웃으로부터 갱시된 거리 벡터를 받고, 라우팅 테이블 엔트리를 재계산하고, 목적지까지 최소 비용 경로의 비용 변경값을 알리는 과정은 더 이상 갱신 메세지가 없을 때까지 계속됨
     + 갱신 메세지가 더 이상 없으면 라우팅 테이블 계산도 더 이상 없으며, 알고리즘은 정지 상태가 됨
     + 즉, 모든 노드는 DV 알고리즘의 10 ~ 11번째 대기 명령을 수행하고 있을 것
     + 즉, 링크 비용이 변할때까지 정지 상태로 존재

-----
### 링크 비용 변경과 링크 고장
-----
1. 링크 비용 변경
   - 거리 벡터 알고리즘을 수행하는 노드가 자신과 이웃 사이 링크의 비용이 변경된 것을 알면, 자신의 거리 벡터를 갱신 후, 최소 비용 경로의 비용에 변화가 있는 경우에만 이웃에게 새로운 거리 벡터를 보냄
   - (a)는 y에서 x로의 링크 비용이 4에서 1로 변한 상황을 보여줌
<div align="center">
<img src="https://github.com/user-attachments/assets/e5e2f5ae-2536-4a84-9309-b7e4d483f143">
</div>

   - 시각 $t_{0}$에 y가 링크 비용의 변화(비용이 4에서 1로 변함)을 감지하고, 자신의 거리 벡터를 갱신 후 이 변경값을 이웃에게 알림
   - 시각 $t_{1}$에 z는 y로부터 갱신 정보를 받고 자신의 테이블을 갱신
     + z는 x까지의 새로운 최소 비용을 계산(5에서 2로 감소)
     + 이웃에게 자신의 새로운 거리 벡터 전송
   - 시각 $t_{2}$에 y는 z로부터 갱신 정보를 받고 자신의 테이블을 갱신
     + y의 최소 비용은 변화가 없으므로 y는 z에게 아무런 메세지를 보내지 않음
     + 즉, 알고리즘은 정지 상태가 됨
   - 따라서, 거리 벡터 알고리즘은 정지 상태가 될 때까지 2번만 반복하면 됨
   - x와 y간의 비용이 감소한다는 것은 네트워크 전역으로 전송

2. 링크 비용이 증가
   - x와 y 사이에서 링크 비용이 (b)와 같이 4에서 60으로 증가
   - 링크 비용이 변경되기 전, $D_{y}(x) = 4$, $D_{z}(y) = 1$, $D_{z}(x) = 5$
   - 시각 $t_{0}$에 y가 링크 비용의 변화를 감지하고(비용이 4에서 60으로 변함), 노드 x까지의 다음의 비용을 갖는 새로운 최소 비용 경로 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/6d05a22a-12a1-423b-8e4d-f710c05782cb">
</div>

   - z를 경유하는 새로운 비용이 잘못되었지만, 노드 y가 가진 유일한 정보는 x까지 직접 가는 경로 비용이 60이고, z가 가장 최근에 y에게 x에 도착하려면 5의 비용이 필요한 것을 명시한 것일 뿐
     + 따라서, y는 z가 비용 5로 x에 도달할 수 있으리라 기대하고 z를 x로 가기 위해 다음 노드로 선택
     + 따라서, 시각 $t_{1}$에 x로 가기 위해 y는 z로 경로 설정을 하고, z는 y로 경로 설정을 하는 라우팅 루프(Routing Loop)가 발생
     + 즉, $t_{1}$에 x를 목적지로 하는 패킷이 y나 z에 도착하면 이 두 노드 사이에 영원히 (포워딩 테이블이 변할 때까지) 왔다 갔다 순환할 것
   - 노드 y는 x까지의 새로운 최소 비용을 계산했으므로 $t_{1}$ 시각에 z에게 새로운 거리 벡터를 알림
   - $t_{1}$ 시각 얼마 이후 z는 y의 새로운 거리 벡터를 받고, y에서 x로의 최소 비용이 6임을 알게 되며, z는 y에 도달하기 위해 비용 1이 필요하다는 사실을 알고 있으므로, x로의 새로운 최소 비용 $D_{z}(x) = min(50 + 0, 1 + 6)$을 계산하고, x까지의 z의 최소 비용이 증가했으므로, $t_{2}$ 시각에 새로운 거리 벡터를 y에 알림
   - 비슷한 방법으로 z의 새로운 거리 벡터 수신 후, y는 $D_{y}(x) = 8$을 결정하고, 이 거리 벡터를 z에게 보냄
     + 그러면 z는 $D_{z}(x) = 9$로 결정하고, 이 거리 벡터를 y에게 보내는, 이런 식으로 계속 반복

   - 이 프로세스는 z의 y를 통한 경로 비용 계산값이 50보다 커질때까지 44번 루프를 반복(y와 z 간 메세지 교환)
   - 44번쨰 반복 이후, z는 마침내 x와 직접 연결을 통해 x로의 최소 비용 경로를 결정하고, y는 z를 통해 x로 가는 경로 설정
   - 이런 문제를 무한 계수 문제(Count-to-Infinity Problem)이라고 함

-----
### 포이즌 리버스(Poisoned Reverse)
-----
1. 위의 라우팅 루프 시나리오는 포이즌 리버스라는 방법을 사용해 방지 가능
   - 만약 z가 y를 통해 목적지 x로 가는 경로 설정을 했다면, z는 y에게 x까지의 거리가 무한대라고 알림
   - 즉, z는 y에게 $D_{z}(x) = ∞$(실제로는 z가 $D_{z}(x) = 5$임을 알더라도)로 알림
   - z는 y를 통과해서 x로 가는 동안 이러한 선의의 거짓말을 계속하며, y는 z에서 x로 가는 경로가 없다고 믿으므로, z가 ㄱ속해서 y를 통해 x로 가는 경로를 사용하는 동안 y는 z를 통해 x로 가는 경로를 시도하지 않을 것
  
2. 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/fd424095-35a2-4fc8-87a0-3ee005022b25">
</div>

   - 포이즌 리버스의 결과로 y의 거리 테이블은 $D_{z}(x) = ∞$ 값을 가짐
   - $t_{0}$ 시각에 링크 (x, y)의 비용이 4에서 60으로 변함
     + y는 테이블을 갱신하고 비록 60이라는 높은 비용에도 x로 직접 라우팅하며 z에게 x로의 새로운 비용 $D_{y}(x) = 60$을 알림
   - $t_{1}$ 시각에 갱신 정보를 받은 뒤 z는 즉시 x로의 경로를 비용이 50인 직접 연결 (x, y)로 변경
   - 이 경로는 x로의 새로운 최소 비용 경로이며, 더 이상 y를 통과하지 않으므로, z는 $t_{2}$ 시각에 $D_{z}(x) = 50$을 알림
     + z에게서 갱신 메세지를 받은 뒤, y는 거리 테이블을 $D_{y}(x) = 51$로 갱신
   - 💡 z는 이제 y에서 x로의 최소 비용 경로상에 있으므로 y는 $t_{3}$ 시각에 $D_{y}(x) = ∞$ ($D_{y}(x) = 51$임을 알고 있음) z에게 알림으로 z에서 x로의 역 경로 차단

3. 포이즌 리버스의 모든 무한 계수 문제를 해결할 수 없음
   - 직접 이웃한 2개의 노드가 아닌 3개 이상의 노드를 포함한 루프는 포이즌 리버스로 감지 불가
