-----
### 거리 벡터(DV) 라우팅 알고리즘
-----
1. 링크 상태 알고리즘이 네트워크 전체 정보를 이용하는 알고리즘인 반면, 거리 벡터(DV, Distance-Vector) 알고리즘은 반복적이고 비동기적이며 분산적
2. 각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 이웃들에게 배포한다는 점에서 분산적(Distributed)
3. 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다는 점에서 반복적(Iterative) (이 알고리즘은 자기 종료를 함(즉, 계산을 멈추라는 신호가 없어도 알아서 멈춤)
4. 모든 노드가 정확히 맞물려 동작할 필요가 없으므로 비동기적(Asynchronous)
5. 최소 비용 경로의 비용들 사이의 관계 - 벨만-포드(Bellman-Ford) 식에 의한 최소 비용 계산
   - 노드 x에서부터 y까지의 최소 비용 경로의 비용을 $d_{x}(y)$
<div align="center">
<img src="https://github.com/user-attachments/assets/7b23df6b-2e80-418c-af0e-04e1c356e457">
</div>

   - $min_{v}$는 x의 모든 이웃에 적용
   - x에서 v로 이동한 후, v에서 y까지 최소 비용 경로를 택한다면, 경로 비용은 c(x, y) + $d_{v}(y)$
   - 반드시 하나의 이웃 v로 가는 것부터 시작해야 하므로, x에서 y까지 최소 비용은 모든 이웃 노드 v에 대해 계산된 c(x, y) + $d_{v}(v)$ 중 최솟값
<div align="center">
<img src="https://github.com/user-attachments/assets/66c97c12-3236-490c-8654-09f85de5f1b5">
</div>

   - 출발지 노드 u는 노드 v, x, w라는 3개의 이웃을 가지며, 그래프에서 여러 경로들을 따라가보면 $d_{v}(z) = 5$, $d_{x}(z) = 3$, $d_{w}(z) = 3$
   - 이 값들을 c(u, v) = 2, c(u, x) = 1, c(u, w) = 5이므로, $d_{u}(z) = min(2 + 5, 5 + 3, 1 + 3)$을 얻게 되며, 이는 네트워크에 다익스트라 알고리즘을 적용해 얻은 결과와 정확히 일치

6. 벨만-포드 식의 해답은 각 노드 포워딩 테이블의 엔트리 제공
   - 위 식에서 최소로 만드는 이웃 노드를 $v^{*}$라고 가정
   - 이 때, 만약 노드 x가 노드 y에게 최소 비용 경로로 패킷을 보내기 원한다면, 노드 x는 패킷을 노드 $v^{*}$로 전달해야 함
   - 그러므로 노드 x의 포워딩 테이블에는 최종 목적지 y로 가기 위한 다음 홉 라우터로 $v^{*}$가 지정되어야 함
   - 즉, DV 알고리즘에서 일어나는 이웃 간 통신 형식을 제안
     + 예를 들어, 출발지 노드를 x라고 하면, 노드 x는 자신으로부터 집합 N에 속한 다른 모든 노드 y까지의 최소 비용 경로의 비용 $D_{x}(y)$를 추정
     + $D_{x} = [D_{x}(y) : y in N]$을 노드 x에서부터 N에 속한 모든 다른 노드 y까지의 비용 추정 값의 벡터라고 하면, DV 알고리즘으로 각 노드 x는 다음 라우팅 정보 유지
       * 각 이웃 노드 v 중 x에 직접 접속된 이웃 노드까지 비용 c(x, y)
       * 노드 x의 거리 벡터, 즉 x로부터 N에 있는 모든 목적지 y로의 비용 예측값을 포함하는 벡터 $D_{x} = [D_{x}(y) : y in N]$
       * 이웃 노드들의 거리 벡터들, 즉 v가 x의 이웃이라고 하면, $D_{v} = [D_{v}(y) : y in N]$

   - 분산적이고 비동기적으로 동작하는 알고리즘에서 각 노드가 자신의 거리 벡터를 때때로 이웃들에게 보냄
   - 노드 x가 이웃 w에게서 새로운 거리 벡터를 수신하면, x는 w의 거리 벡터를 저장하고 벨만-포드 식을 사용해 자신의 거리 벡터 갱신
<div align="center">
<img src="https://github.com/user-attachments/assets/8003f6d7-2465-45da-a26d-74eea6102e91">
</div>

   - 만약 이 갱신으로 인해 노드 x의 거리 벡터가 변경된다면, 노드 x는 이 수정된 거리 벡터를 자신의 이웃들에게 보내고, 그에 따라 이웃들도 자식의 거리 벡터 갱신
   - 모든 노드가 자신의 거리 벡터를 비동기적으로 교환하는 동작을 계속하게 되면, 비용 추정값 $D_{x}(y)$는 노드 x에서 노드 y까지의 실제 최소 비용 경로 비용인 $d_{x}(y)$로 수렴

-----
### 거리 벡터 (DV) 알고리즘
-----
1. 각 노드 x에서
<div align="center">
<img src="https://github.com/user-attachments/assets/5efd93fc-a487-4645-8817-48140b078a02">
</div>

2. DV 알고리즘에서는 어떤 노드 x가 자신에게 직접 연결된 링크 중 하나의 비용이 변경된 사실을 알게되거나 어떤 이웃으로부터 변경된 거리 벡터를 수신했을 때 자신의 거리 벡터 추정값을 계산
3. 💡 그러나 특정 목적지 y에 대한 자신의 포워딩 테이블을 갱신하기 위해 노드 x가 알아야 하는 것은 y까지의 최단 경로가 아닌 y로의 최단 경로상의 다음 홉 라우터인 이웃 노드 $v^{*}(y)$
   - 다음 홉 라우터는 $v^{*}(y)$는 DV 알고리즘 14번째 줄에서 최솟값을 갖게 하는 이웃 v (만약, 최솟값을 갖게 하는 여러 개 이웃이 있다면, 그 중 어느 것이든 될 수 있음)
   - 즉, 각 목적지 y에 대해 노드 x는 $v^{*}(y)$를 결정하고 목적지 y에 대해 포워딩 테이블도 갱신

4. LS 알고리즘은 다익스트라 알고리즘을 수행하기 전 각 노드가 네트워크에 대한 전체 지도를 먼저 얻어야 하므로 중앙 집중형 알고리즘이지만, DV는 분산적이고 그러한 전체 정보를 사용하지 않고 하나의 노드가 갖는 정보는 단지 자신에게 직접 연결된 이웃으로의 링크 비용과 그 이웃들로부터 수신하는 정보뿐임
   - 각 노드는 이웃으로부터 갱신을 기다림
   - 업데이터를 수신하면 새로 거리 벡터 계산
   - 이 새로운 거리 벡터를 이웃들에게 배포
   - DV의 유사 알고리즘은 실제 인터넷의 RIP, BGP, ISO IDRP, 최초 ARPAnet을 포함해 많은 라우팅 알고리즘에서 사용

5. 세 노드로 이루어진 단순한 네트워크의 거리 벡터 알고리즘 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/38e11189-acec-472d-af82-1f8e1c476268">
</div>

   - 알고리즘 동작은 동기적
   - 즉, 모든 노드가 동시에 이웃에게서 거리 벡터를 받고, 새로운 거리 벡터를 계산해서 변화가 있다면 그들의 이웃에게 알림
   - 그림의 가장 왼쪽 열 : 세 노드 각 최초의 라우팅 테이블 모습
     + 특정 라우팅 테이블에서 각 행은 거리 벡터
     + 구체적으로, 각 노드의 라우팅 테이블은 자신과 이웃들의 거리 벡터를 가짐
     + 그러므로 노드 x의 초기 라우팅 테이블 첫 번째 행은 $D_{x} = [D_{x}(x), D_{x}(y), D_{x}(z)] = [0, 2, 7]$
     + 두 번째, 세 번째 행은 각 노드 y와 z로부터 받은 가장 최근의 거리 벡터
     + 최초 노드 x가 y와 z로부터 받은 것이 아무것도 없으므로 이 엔트리들은 무한대로 초기화

   - 초기화 이후, 각 노드는 자신의 두 이웃에게 각 자신의 거리 벡터를 보냄
     + 이 과정은 첫 번째 열에서 두 번째 열로 가는 화살표로 표현
     + 노드 x는 자신의 거리 벡터 $D_{x} = [0, 2, 7]$를 노드 y와 노드 z에게 보냄
     + 갱신을 수신한 후 각 노드는 자신의 거리 벡터를 재계산
     + 노드 x는 다음을 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/99f5fa7f-df0b-49a4-94ec-958d96f347ce">
</div>

   - 각 노드 테이블의 두 번째 열은 이웃으로부터 방금 수신한 거리 벡터와 함께 노드의 새로운 거리 벡터를 보여줌
     + 예를 들어, 노드 x의 노드 z까지의 최소 비용 추정값 $D_{x}(z)$가 7에서 3으로 변경
     + 또한, 노드 x의 테이블에서 이웃 노드 y는 알고리즘의 14번째 줄이 최솟값이 되게 하는 노드로, 이 단계에서 노드 x에는 $v^{*}(y) = y, v^{*}(z) = y$가 기록
     
   - 노드들이 거리 벡터를 재계산한 후에, 만약 변화가 있다면 갱신된 거리 벡터를 다시 이웃들에게 보내며, 테이블의 두 번쨰 열에서 세 번째 열로 가는 화살표로 표현
     + 여기서는 노드 x와 z만이 거리 벡터 정보를 보냄 (노드 y의 거리 벡터는 변하지 않았으므로 노드 y는 거리 벡터 정보를 보내지 않음)
     + 새로운 거리 벡터 정보를 수신하면 세 번째 열에 보인대로 노드는 자신의 거리 벡터를 재계산하고 라우팅 테이블 갱신

   - 이웃으로부터 갱시된 거리 벡터를 받고, 라우팅 테이블 엔트리를 재계산하고, 목적지까지 최소 비용 경로의 비용 변경값을 알리는 과정은 더 이상 갱신 메세지가 없을 때까지 계속됨
     + 갱신 메세지가 더 이상 없으면 라우팅 테이블 계산도 더 이상 없으며, 알고리즘은 정지 상태가 됨
     + 즉, 모든 노드는 DV 알고리즘의 10 ~ 11번째 대기 명령을 수행하고 있을 것
     + 즉, 링크 비용이 변할때까지 정지 상태로 존재
