-----
### 라우팅 알고리즘
-----
1. 목표 : 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로(루트, 최소 비용 경로)를 결정하는 것
   - 네트워크 제어 평면이 라우터별 제어 방식을 채택하든, 논리적 중앙 집중형 방식을 채택하든 상관없이 패킷이 전송 호스트에서 수신 호스트로 이동하기 위한 잘 정의된 일련의 라우터가 항상 존재해야 함

2. 그래프 이용
   - 그래프(Graph) : G(N, E)로 나타내며, N은 노트(Node), E는 엣지(Edge)의 집합으로, 하나의 엣지는 집합 N에 속하는 한 쌍의 노드로 표시
   - 네트워크 계층 라우팅 상황에서 그래프 상 노드는 패킷의 전달 결정이 이루어지는 지점인 라우터를 나타냄
   - 이 노드들을 연결하는데 엣지는 라우터들 간의 물리링크를 나타냄
   - 노드는 각 네트워크를 나타내고, 이러한 두 노드를 연결하는 엣지는 두 네트워크의 연결(Peering)

3. 엣지는 그 비용을 나타내는 값을 가짐
   - 이 비용은 일반적으로 해당 링크의 물리적인 거리, 링크 속도, 링크와 관련됨 금전적 비용 등 반영
   - 링크 비용이 어떻게 계산되었는지 상관하지 않고, 단순히 주어진 비용을 사용한다고 가정
   - 집합 E에 포함된 어떤 엣지 (x, y)에 대해 c(x, y)는 노드 x와 y간의 비용을 의미하며, 노드 쌍 (x, y)가 E에 포함되지 않으면, c(x, y) = ∞
   - 또한, 모든 엣지가 방향성을 갖지 않는 무방향성 그래프만을 고려하며, 양방향으로 서로 다른 비용을 갖는 방향성 링크의 경우로 쉽게 확장이 가능
   - 엣지 (x, y)가 집합 E에 속하면, 노드 y는 노드 x의 이웃(Neigbor)
  
4. 그래프의 여러 엣지에 비용이 할당되고 나면 라우팅 알고리즘은 자연적으로 출발지와 목적지 간 최소 비용을 경로를 찾는 것을 목표로 함
   - 그래프 G(N, E)에서의 경로는 노드의 연속 ($x_{1}, x_{2}, ..., x_{p}$)이고, 노드 쌍 ($x_{1}, x_{2}$), ($x_{2}, x_{3}$), ..., ($x_{p - 1}, x_{p}$)는 집합 E에 속한 엣지
   - 경로 ($x_{1}, x_{2}, ..., x_{p}$)의 비용은 경로 상 모든 엣지 비용의 단순 합, 즉 c($x_{1}, x_{2}$) + c($x_{2}, x_{3}$) + ... + ($x_{p - 1}, x_{p}$)
   - 💡 어떤 두 노드 x, y가 주어지면 일반적으로 두 노드 간 많은 경로가 존재하고 각 경로는 비용을 갖는데, 이 중 최소 비용 경로(Least-cost Path)는 하나일 수 있고 여러 개 일 수 있음
   - 출발지와 목적지 간 최소 비용을 경로를 찾는 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/a5f82b68-2043-49b4-bc21-f92d11ce3f62">
</div>

   - 출발지 노드 u와 목적지 노드 w 사이 최소 비용 경로는 경로 비용이 3인 (u, x, y, w)
     + 만약, 그래프의 모든 엣지가 같은 비용을 가지면, 최소 비용 경로가 바로 최단 경로(출발지와 목적지 사이에 최소 개수의 링크만을 포함하는 경로)

5. 라우터 알고리즘을 분류하는 일반적인 방법
   - 중앙 집중형 라우팅 알고리즘(Centralized Routing Algorithm) / 분산 라우팅 알고리즘 (Decentralized Routing Algorithm)
     + 중앙 집중형 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 상 최소 경로 비용을 계산하는데, 모든 알고리즘은 모든 노드 사이의 연결 상태의 링크 비용을 입력값으로 함 (따라서, 알고리즘이 실제 수행하기 전 어떠한 방법을 통해서라도 얻어야 함)
       * 계산 자체는 한 장소(예) 논리적 중앙 집중형 컨트롤러)에서 수행되거나 모든 라우터 각 라우팅 모듈로 복사될 수 있음
       * 핵심은 이 알고리즘이 연결과 링크 비용에 대한 완전한 정보를 가지므로, 이러한 전체 상태 정보를 갖는 알고리즘을 링크 상태(Link State, LS) 알고리즘이라고 하며, 이 알고리즘은 네트워크 내 각 링크 비용을 알고 있어야 함

     + 분산 라우팅 알고리즘 : 최소 비용 경로 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행
       * 어떤 노드도 모든 링크의 비용에 대한 완전한 정볼르 가지지 않지만, 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 시작하며, 이후, 반복된 계산과 이웃 노드와의 정보 교환을 통해 노드는 점차적으로 목적지 또는 목적지 집합까지 최소 비용 경로 계산
       * 거리 벡터 알고리즘(Distance-Vetor, DV) 알고리즘이라 불리는데, 각 노드가 네트워크 내 다른 모든 노드까지 비용(거리)의 추정값을 벡터 형태로 유지하기 때문임
       * 이웃한 라우터들끼리 반복적으로 메세지를 교환하는 분산형 알고리즘은 제어 평면에서 더 자연스러움

    - 정적 알고리즘 / 동적 알고리즘
      + 정적 라우팅 알고리즘 (Static Routing Algorithm) : 경로는 아주 느리게 변하는데, 종종 사람이 개입(예) 사람이 직접 링크 비용 수정)한 결과
      + 동적 라우팅 알고리즘 (Dynamic Routing Algorithm) : 네트워크 트래픽 부하(Load)나 토폴로지 변화에 따라 라우팅 경로가 바뀜
        * 주기적으로, 혹은 토폴로지나 링크 비용의 변경에 직접적으로 응답하는 방식으로 수행
        * 네트워크 변화에 빠르게 대응할 수 있지만, 경로의 루프(Loop)나 경로 진동(Oscillation) 같은 문제에 취약

    - 라우팅 알고리즘이 부하에 민감 / 민감하지 않음
      + 부하에 민감한 알고리즘 (Load-Sensitive Algorithm) : 링크 비용은 해당 링크의 현재 혼잡 수준을 나타내기 위해 동적으로 변하는데, 현재 혼잡한 링크에 높은 비용을 부과하면, 라우팅 알고리즘은 혼잡한 링크를 우회하는 경로를 택하는 경향 보임
      + 초기 ARPAnet 라우팅 알고리즘이 부하에 민감해서 많은 어려움이 존재
      + 오늘날 인터넷 라우팅 알고리즘(RIP, OSFP, BGP 등)은 링크 비용이 현재(또는 가장 최근) 혼잡을 반영하지 않으므로 부하에 민감하지 않음 (Load-Insensitive Algorithm)
