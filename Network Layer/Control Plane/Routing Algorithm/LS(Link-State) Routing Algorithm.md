-----
### 링크 상태 라우팅 알고리즘
-----
1. 네트워크 토폴리지와 모든 링크 비용이 알려져있어서 링크 상태 알고리즘의 입력값으로 사용 가능
   - 각 노드가 자신과 직접 연결된 링크의 식별자와 비용 정보를 담은 링크 상태 패킷을 네트워크 상의 다른 모든 노드로 브로드캐스트함으로써 가능
   - 링크 상태 브로드캐스트(Link-State BroadCast) 알고리즘에 의해 수행
   - 노드들의 브로드캐스트를 통해 모든 노드는 네트워크에 대해 동일하고 완벽한 관점을 갖게 되며, 각 노드는 LS 알고리즘을 이용해 다른 노드와 똑같은 최소 비용 경로 집합 계산 가능

2. 다익스트라 알고리즘(Dijkstra's Algorithm)이라고 불림 (밀접히 관련된 알고리즘 : 프림 알고리즘(Prim's Algorithm)
   - 하나의 노드(출발지, u라고 가정)에서 네트워크 내 다른 모든 노드로의 최소 비용을 계산
   - 반복적이고 알고리즘의 $k$번째 반복 이후 $k$개의 목적지 노드에 대해 최소 비용 경로가 알려지며, 이 $k$개의 경로는 모든 목적지 노드로의 최소 비용 경로 중 가장 낮은 비용의 갖는 $k$개의 경로
     + $D(v)$ : 알고리즘 현재 반복 시점에서 출발지 노드부터 목적지 $v$까지 최소 비용 경로 비용
     + $p(v)$ : 출발지에서 $v$까지의 현재 최소 비용 경로에서 $v$의 직전 노드
     + $N′$ : 노드의 집합, 출발지에서 $v$까지 최소 비용 경로가 명확히 알려져 있다면, $v$는 $N′$에 포함

   - 중앙 집중형 라우팅 알고리즘은 초기화 단계와 반복 부분으로 구성되며, 수행 횟수는 네트워크 노드 수와 같음
   - 반복 부분 수행이 종료되면 알고리즘은 출발지 노드 $u$에서 네트워크 상 다른 모든 노드로의 최단 경로 산출 가능

3. 출발지 노드 u를 위한 링크 상태 알고리즘
<div align="center">
<img src="https://github.com/user-attachments/assets/9cb06aaf-37bd-4f63-944f-d1119cc2bff4">
</div>

   - 네트워크에서 u부터 모든 가능한 목적지 까지 최소 비용 경로 계산
   - 알고리즘 계산 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/fdea6cfa-5726-4d06-8cd8-ac3c8aa53426">
</div>

   - 초기화 단계에서 u로부터 직접 연결된 이웃 v, x, w까지의 현재 알려진 최소 비용 경로는 각 2, 1, 5로 초기화
     + 특히 u에서 w로의 직접 연결된 (1홉) 링크의 비용이 5이므로, w까지의 비용이 5로 설정
     + y와 z는 u에 직접 연결되지 않았으므로 이들까지 비용은 무한대

   - 첫 번째 반복에는 $N′$ 집합에 아직 포함되지 않은 노드 중에 이전 반복이 끝난 시점에서 최소 비용을 갖는 노드를 찾음
     + 그에 해당하는 노드는 비용 1을 갖는 x이므로 x를 집합 $N′$에 추가
     + 모든 노드 v에 대한 $D(v)$를 갱신하기 위해 링크 상태 알고리즘을 수행
     + V로의 경로 비용은 변하지 않지만, 한편 노드 x를 통한 w로의 경로 비용은 4로 변경 (더 낮은 비용을 갖는 경로를 찾음)
     + 따라서, 이 경로가 선택되고, u에서부터 w까지 최단 경로상의 w의 직전 노드는 x가 됨
     + 마찬가지로, y로의(x를 통한) 비용은 2이므로 테이블이 그에 맞게 갱신

   - 두 번째 반복에서는 노드 x와 y가  최소 경로 비용(2)를 갖는다는 사실을 알게 되므로 둘 중 임의로 하나를 골라 y를 $N′$에 넣음
     + 이제 $N′$에는 u, x, y가 존재하며, $N′$에 없는 남은 노드들까지의 비용, 즉 y, w, z까지의 비용은 링크 상태 알고리즘에 의해 갱신
     + 위 표 결과와 동일

   - 링크 상태 알고리즘이 종료된 후에는 각 노드에 대해 출발지 노드로부터의 최소 비용 경로 상 직전 노드를 알게 됨
     + 각 직전 노드는 또 그 직전 노드를 가지며, 이러한 방식으로 출발지에서 모든 목적지까지의 전체 경로 구축 가능
     + 한 노드, 예를 들어 노드 u의 포워딩 테이블은 각 목적지에 대해 노드 u에서 그 목적지까지의 최소 비용 경로상의 다음 홉 노드 정보를 저장하여 구성
<div align="center">
<img src="https://github.com/user-attachments/assets/22ebca34-c6e1-4081-9f26-e9a3b38b04fa">
</div>

4. 알고리즘의 계산 복잡도
   - 즉, n개의 노드(출발지 노드 제외)가 있다면, 첫 번째 반복에서는 최소 비용이 이미 계산된 노드 집합 $N′$에 포함되지 않은 노드 w를 결정하기 위해 모든 n개 노드 검사
   - 두 번째 반복에서는 최소 비용을 결정하기 위해 n - 1개의 노드 검사
   - 세 번째 반복에서는 n - 2개의 노드를 검사
   - 따라서, 찾아야 하는 노드 총 수는 (n * (n + 1)) / 2이며, 최악의 경우 $O(n^2)$ 복잡성을 가짐
     + 힙(Heap) 데이터 구조를 활용한 좀 더 개선된 방식으로 구현한 알고리즘은 로그 급수 시간으로 최솟값을 찾을 수 있으므로 계산 복잡도 감소

5. 발생할 수 있는 문제
<div align="center">
<img src="https://github.com/user-attachments/assets/43a56dbc-f7ed-4475-a237-e1687d4c4e15">
</div>

   - 단순한 네트워크 토폴리지로서 링크 비용은 링크를 통과하는 트래픽 부하와 같고, 이는 패킷이 겪을 수 있는 지연 시간 반영 (링크 비용은 대칭적이지 않음)
   - 즉, 링크 (u, v)의 양방향으로 전달되는 부하가 같은 경우에만 c(u, v)와 c(v, u)가 같음
   - 이 예에서는 노드 z와 노드 x는 w를 목적지로 하는 1단위 트래픽을 생성, 노드 y는 e 단위 트래픽을 생성해 w에게 보냄
   - 초기 상태는 (a)와 같으며, 링크 상태 알고리즘이 다시 수행되면 노드 y는 w로 가는 시계 방향 경로 비용이 1인 반면, 반시계 방향으로의 경로 비용은 1 + e임 ((a) 링크 비용 기반)
   - 따라서, w로 가는 y의 최소 비용 경로는 시계 방향
   - 마찬가지로 x도 w로 가는 시계 방향 경로를 새로운 최소 비용 경로로 결정하고, (b)와 같은 경로 비용을 나타냄
   - 여기서, 다시 한 번 링크 상태 알고리즘이 수행되면 노드 x, y, z는 모두 w로 가는 반시계 방향의 경로 비용이 0임을 알게 되어 모든 트래픽을 반시계 방향으로 경로를 보내고, 다음 링크 상태 알고리즘 수해 시에는 x, y, z 모두 시계 방향으로 트래픽 전송
   - 이러한 진동(Oscillation) 문제(링크 상태 알고리즘 뿐 아니라 혼잡이나 지연 시간 기반으로 링크 비용을 산출하는 모든 알고리즘에서 발생 가능)가 발생

6. 진동 문제 해결 방법
   - 링크 비용이 해당 링크가 전달하는 트래픽 양에 의존하지 않도록 하는 방법 : 하지만 라우팅의 한 가지 목적이 매우 혼잡한(높은 지연을 발생시키는) 링크를 회피하는 것이므로 받아들이기 어려움
   - 모든 라우터가 동시에 링크 상태 알고리즘을 실행하지 못하도록 할 것
     + 라우터들이 동일한 주기 간격으로 링크 상태 알고리즘을 수행한다 하더라도 각 노드에서 알고리즘의 실행 시각이 같지 않을 것
     + 하지만, 인터넷 라우터들이 스스로 자기들끼리 동기를 맞춤
     + 즉, 라우터들이 알고리즘을 처음에는 각기 다른 시작 시간에, 그러나 같은 주기를 갖도록 해서 실행하더라도 점진적으로 결국엔 서로 동기화 됨
     + 이러한 자기 동기화는 각 노드가 링크 상태 정보를 송신하는 시각을 임의로 결정하게 함으로 회피 가능
