-----
### 링크 상태 라우팅 알고리즘과 거리 벡터 라우팅 알고리즘 비교
-----
1. DV와 LS 알고리즘은 경로를 계산할 때 서로 대비됨
   - DV 알고리즘 : 각 노드는 오직 직접 연결된 이웃과만 메세지를 교환하지만, 자신으로부터 네트워크 내 (자신이 알고 있는) 모든 노드로의  최소 비용 추정값을 이웃들에게 제공
   - LS 알고리즘 : 전체 정보를 필요로 하며, 각 노드는 다른 모든 노드와 (브로드캐스트를 통해) 통신하지만, 오직 자신에 직접 연결된 링크의 비용만 알림

2. 두 알고리즘의 비교 (N은 노드(라우터) 집합, E는 엣지(링크)의 집합)
   - 메세지 복잡성
     + 링크 상태 알고리즘에서 각 노드는 네트워크 내 각 링크 비용을 알아야 하는데, 이를 위해서 $O(|N||E|)$ 메세지가 전송되어야 하며, 또한, 링크 비용이 변할때마다 새로운 링크 비용이 모든 노드에게 전달되어야 함
     + 거리 벡터 알고리즘에서는 매번 반복마다 직접 연결된 이웃끼리 메세지를 교환하는데, 알고리즘 결과가 수렴하는 데 걸리는 시간은 많은 요소에 의해 좌우됨
       * 또한, 링크 비용이 변하고, 이 새로운 링크 비용이 이 링크에 연결된 어떤 노드의 최소 비용 경로에 변화를 준 경우에만 DV 알고리즘은 수정된 링크 비용 전파

   - 수렴 속도
     + 링크 상태 알고리즘은 $O(|N||E|)$개의 메세지를 필요로 하는 $O(|N||^{2})$ 알고리즘
     + 거리 벡터 알고리즘은 천천히 수렴하고 알고리즘이 수렴하는 동안 라우팅 루프 발생 가능하며, 무한 계수 문제 발생 가능
    
    - 견고성 (만약 라우터가 고장나거나 오작동하거나 파손되는 경우가 발생)
      + 링크 상태 알고리즘에서 라우터는 연결된 링크(다른 링크들은 상관 없음)에 대해 잘못된 비용 정보를 브로드캐스트 할 수 있으며, 또한 노드는 링크 상태 브로드캐스트를 통해 받은 패킷을 변질시키거나 폐기할 수 있음
        * 그러나 하나의 링크 상태 노드는 자신의 포워딩 테이블만 계산하고, 다른 노드들 역시 자신의 테이블을 만들기 위한 유사한 계산 수행
        * 이는 링크 상태 알고리즘이 경로 계산에 어느정도 분산되어 수행함을 의미하며, 어느 정도 견고성 제공
      + 거리 벡터 알고리즘에서 노드는 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에 알릴 수 있음
        * 일반적으로, 각 반복마다 한 노드의 거리 벡터 계산이 이웃에게 전달되고 다음 반복에서 이웃의 이웃에게 간접적으로 전달
        * 이런 측면에서 거리 벡터 알고리즘을 사용하는 네트워크에서 한 노드의 잘못된 계산은 전체로 확산 가능

3. 따라서, 두 알고리즘 중 어느 알고리즘이 명백히 낫다고 말할 수 없으며, 실제로 두 알고리즘 모두 인터넷에서 사용
