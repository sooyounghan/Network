-----
### DNS (Domain Name Server)
-----
1. 호스트 식별자 중 하나는 호스트 이름(Host Name)
   - 하지만, 호스트 이름은 인터넷에서의 그 호스트 위치에 대해 정보를 거의 제공하지 않음
   - 호스트는 흔히 IP 주소로도 식별
     + IP 주소는 4바이트로 구성, 계층 구조를 가짐
     + 0 ~ 255의 십진수로 표현하고, 각 바이트는 점으로 구분 (예) ```121.7.106.83```)
     + 계층구조이므로 주소를 왼쪽에서 오른쪽으로 조사함으로, 그 호스트가 인터넷 어디에 위치하는지 자세한 정보를 얻을 수 있음

2. DNS가 제공하는 서비스
   - 라우터는 고정 길이 계층구조를 가진 IP 주소를 참조하므로, 호스트 이름을 IP 주소로 변환해주는 디렉토리 서비스가 필요한데 이것이 DNS
   - DNS 서버들의 계층구조로 구현된 분산 데이터베이스
   - 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜
   - DNS 서버는 주로 BIND(Berkeley Internet Name Domain) 소프트웨어를 수행하는 유닉스 컴퓨터
   - DNS 프로토콜은 UDP 상에서 수행되고 포트 번호 53번 이용

3. 다른 애플리케이션 프로토콜들이 HTTP, SMTP, FTP 등 사용자가 제공한 호스트 이름을 IP 주소로 변환하기 위해 주로 사용
4. 예시) HTTP 클라이언트 URL : ```www.someschool.edu/index.html``` 요청
   - 같은 사용자 컴퓨터는 DNS 애플리케이션 클라이언트 측을 수행
   - 브라우저는 URL로부터 호스트 이름 ```www.someschool.edu```를 추출하고, 그 호스트 이름을 DNS 애플리케이션 클라이언트 측에 넘김
   - DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의 전송
   - DNS 클라이언트는 호스트 이름에 대한 IP 주소를 가진 응답을 받음
   - 브라우저가 DNS로부터 IP 주소를 받으면, 브라우저는 해당 IP 주소와 그 주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결 초기화

5. DNS는  DNS를 사용하는 인터넷 애플리케이션에게 추가 지연이 발생
   - 하지만, IP 주소는 가까운 DNS 서버에 캐싱되어 있으므로, 평균 DNS 지연 및 DNS 네트워크 트래픽 감소에 도움

6. DNS 서비스
   - 호스트 에일리어싱(Host Aliasing)
     + 복잡한 호스트 이름을 가진 호스트는 하나 이상의 별명을 가질 수 있음
     + 정식 호스트 이름과 별칭 호스트 이름으로 존재하는데, 별칭 호스트 이름은 대체로 기억하기 쉬움
     + DNS는 호스트의 IP 주소 뿐 아니라 제시한 별칭 호스트 이름에 대한 정식 호스트 이름을 얻기 위해 이용 가능

   - 메일 서버 에일리어싱(Mail Server Aliasing)
     + DNS는 호스트의 IP 주소뿐만 아니라 제공된 별칭 호스트 이름에 대한 정식 호스트 이름을 얻기 위해 메일 애플리케이션에 의해 수용

   - 부하 분산 (Load Distribution)
     + DNS는 중복 웹 서버 같은 여러 중복 서버 사이 분산을 위해 사용
     + DNS 데이터베이스는 IP 주소 집합을 가지는데, 클라이언트가 주소 집합을 매핑하는 호스트 이름에 대한 DNS 질의를 하며, 서버는 IP 주소 집합 전체를 가지고 응답하지만, 각 응답에서의 주소는 순환식으로 보냄
     + 즉, 클라이언트는 대체로 주소 집합 내부의 첫 번째 IP 주소로 HTTP 요청 메세지를 보내므로, DNS 순환 방식은 여러 중복 사이에서 트래픽을 분산하는 효과 발생
     + 전자 메일에서도 사용되어 여러 메일 서버가 동일 별칭을 가질 수 있음
    
7. DNS 프로토콜
   - 클라이언트-서버 구조로 통신하는 종단 사이에서 수행
   - 통신하는 종단 시스템 사이에서 DNS 메세지를 전달하기 위해 하위 종단 트랜스포트 프로토콜에 의존하므로 애플리케이션 계층 프로토콜
   - 사용자가 직접 상호작용하는 애플리케이션이 아닌, 인터넷에서 사용자가 애플리케이션과 다른 소프트웨어를 위해 호스트 이름을 IP 주소로 변환하는 기능을 제공

-----
### DNS 동작 원리 개요
-----
1. 사용자 호스트에서 실행되는 웹 브라우저 또는 메일 클아이언트 호스트 이름을 IP 주소로 변환하려 한다고 가정
   - 애플리케이션은 변환될 호스트 이름을 명시하여 DNS 측의 클라이언트를 호출
   - 사용자 호스트의 DNS는 네트워크에 질의 메세지를 보내며, 모든 DNS 질의와 응답 메세지는 포트 53의 UDP 데이터그램으로 전송되며, 수 밀리초에서 수 초 지연 후 사용자 호스트의 DNS는 요청한 매핑에 해당하는 DNS 응답 메세지를 받으며, 이 매핑은 호출한 애플리케이션으로 전달
   - 전 세계 분산된 많은 DNS 서버 뿐 아니라, DNS 서버와 질의를 하는 호스트 사이 어떻게 통신하는지 명시하는 애플리케이션 계층 프로토콜로 구성

2. 중앙 집중 방식을 사용하지 않음
   - 서버 고장 : 전체 인터넷이 동작하지 않을 수 있음
   - 트래픽 양 : 단일 DNS 서버가 모든 DNS 질의 처리해야 함
   - 먼 거리의 중앙 집중 데이터베이스 : 심각한 지연 발생 가능
   - 유지 관리 : 단일 네임 서버는 모든 인터넷 호스트에 대한 레코드를 유지해야 하므로, 자주 갱신 및 인증 문제 발생
   - 확장성이 없음

3. 따라서, 분산되도록 설계 - DNS 서버 계층구조
<div align="center">
<img src="https://github.com/user-attachments/assets/c3cea54f-d8fe-468a-9bd0-3e8676c9282c">
</div>

   - 분산 계층 데이터베이스 : DNS는 많은 서버를 이용하고 이들을 계층 형태로 구성하며 전 세계 분산
   - Root DNS 서버, Top-Level Domain(TLD) DNS 서버, Authoriative (책임) DNS 서버로 구성
   - 예시) DNS 클라이언트가 호스트 이름 ```www.amazon.com```의 IP 주소를 결정하기 원한다고 가정
     + 먼저 클라이언트는 루트 서버 중 하나로 접속하며, 루트 서버는 최상위 레벨 도메인 com을 갖는 TLD 서버 IP 주소를 보냄
     + 클라이언트는 TLD 서버 중 하나에 접속하고, 서버는 도메인 ```amazon.com```을 가진 책임 서버의 IP 주소를 보냄
     + 클라이언트는 ```amazon.com``` 책임 서버 중 하나로 접속하고, 서버는 호스트 이름의 IP 주소를 보냄

   - 루트 DNS 서버 : 루트 서버들은 13개의 다른 루트 서버 복사체, 12개의 다른 기관에서 관리되며 인터넷 할당 번호 관리기관에 의해 조정되며, TLD 서버의 IP 주소 제공
   - 최상위 레벨 도메인(TLD) 서버 : com, org, net, edu, gov 같은 상위 레벨 도메인과 kr, uk, fr, ca, jp 같은 모든 국가 상위 레벨 도메인에 대한 TLD 서버(서버 클러스터) 존재하며, 책임 DNS 서버에 대한 IP 주소 제공
   - 책임 DNS 서버 : 인터넷에 접근하기 쉬운 호스트는 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야하며, 이를 가지고 있어야 하며, 자신의 DNS 서버 구현을 선택할 수 있고 비용을 지불해야 함
   - 로컬 DNS 서버 : 서브들의 계층 구조에는 속하지 않지만, DNS 구조의 중심
     + ISP들은 로컬 DNS 서버(디폴트 네임 서버)를 가지며, 호스트가 ISP에 연결될 때, ISP는 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공
     + 호스트의 로컬 DNS 서버는 대체로 호스트에 가까이 존재

<div align="center">
<img src="https://github.com/user-attachments/assets/754c98f0-34df-430f-a4a2-3d7533dd108a">
</div>

4. 예시) 호스트 ```cse.nyu.edu```가 ```gaia.cs.umass.edu```의 IP 주소를 원한다고 가정
   - 또한 ```cse.nyu.edu```에 대한 NYU의 로컬 DNS 서버가 ```dns.nyu.eud```이고, ```gaia.cs.umass.edu```에 대한 책임 DNS 서버가 ```dns.umass.edu```라고 가정
   - 먼저, 호스트 ```cse.nyu.edu```가 자신의 로컬 DNS 서버에게 DNS 질의 메세지를 보내며, 질의에는 변환되어야 하는 이름인 ```gaia.cs.umass.edu```가 포함
   - 로컬 DNS 서버는 그 질의 메세지를 루트 DNS 서버에게 전달
   - 루트 DNS 서버는 edu를 인식하고, edu에 대한 책임을 가진 TLD 서버의 IP 주소 목록을 로컬 DNS 서버에게 전달하며, 로컬 DNS 서버는 질의 메세지를 TLD 서버에 전송
   - TLD 서버는 ```umass.edu```를 인식하고 ```dns.umass.edu```로 이름 지어진 책임 DNS 서버의 IP 주소로 응답
   - 마지막으로, 로컬 DNS 서버는 직접 ```dns.umass.edu```로 질의 메세지를 다시 보내고, ```gaia.cs.umass.edu```의 IP 주소로 응답
   - 하나의 호스트 이름 매핑을 위해 질의 메세지 네 번과 응답 메세지 네 번, 총 8번의 DNS 메세지가 전송

5. 일반적으로 TLD 서버는 호스트 이름에 대해 책임 서버를 알지 않고, 대신 TLD 서버는 호스트 이름에 대한 책임 DNS를 아는 중간 DNS 서버만 알고 있음
   - 중간 DNS 서버가 ```dns.umass.edu```가 ```cs.umass.edu```로 끝나는 호스트 이름을 가진 호스트 질의를 받으면, ```cs.umass.edu```로 끝나는 모든 호스트에 대한 책임을 가진 ```dns.cs.umass.edu```의 IP 주소를 ```dns.nyu.edu```로 전달
   - 로컬 DNS 서버는 로컬 DNS 서버에게 원하는 매핑 결과를 돌려주는 책임 DNS 서버에게 질의를 보내며, 로컬 DNS 서버는 요청한 호스트에게 그 매핑을 전달하므로 2번 더해진 10번의 메세지를 보냄

6. 재귀적 질의(Recursive Query)와 반복적 질의(Iterative Query)
   - ```cse.nyu.edu```로부터  ```dns.nyu.eud```로 보내는 질의는 자신을 대신하여 필요한 매핑을 얻도록  ```dns.nyu.eud```에게 요구하므로 재귀적 질의
   - 나머지 세 질의는 응답이  ```dns.nyu.eud```에게 직접 보내지므로 반복적 질의
   - 이론상, DNS 질의 반복적이고 재귀적일 수 있음
   - 즉, 요청하는 호스트로부터 로컬 DNS 서버까지의 질의는 재귀적, 나머지 질의는 반복적

7. DNS 캐싱
   - DNS는 지연 성능 향상과 네트워크의 DNS 메세지 수를 줄이기 위해 캐싱 사용
   - 질의 사슬에서 DNS 서버가 DNS 응답을 받았을 때 로컬 메모리에 응답에 대한 정보 저장 가능
   - 만약, 호스트 이름과 IP 주소 쌍이 DNS에 저장되고 다른 호스트 이름으로부터 같은 질의가 DNS 서버로 도착하면 DNS 서버는 호스트 이름에 대한 책임이 없을떄 조차 IP 주소 제공 가능 (단, 일정 기간 이후 저장된 정보들은 제거)
   - 예) 호스트 ```apricot.nyu.edu```가 ```cnn.com```에 대한 IP 주소를 ```dns.nyu.edu```에게 질의 후, NYU의 다른 호스트 ```kiwi.nyu.edu```가 같은 호스트 이름을 질의한다고 가정
     + 캐싱으로 로컬 DNS 서버는 두 번쨰 질의한 호스트에게 다른 DNS 서버로 질의 없이 즉시 ```cnn.com``` IP 주소 전송 가능
   - 로컬 DNS 서버는 또한 TLD 서버의 IP 주소 저장이 가능하므로, 로컬 DNS 서버가 질의 사슬에서 루트 DNS 서버 우회 가능 (자주 발생)

-----
### DNS 레코드와 메세지
-----
1. DNS 분산 데이터베이스를 구현한 DNS 서버들은 호스트 이름을 IP 주소로 매핑하기 위해 자원 레코드(Resource Record, RR)를 저장하며, 각 DNS는 하나 이상의 자원 레코드를 가진 메세지로 응답
2. 자원 레코드는 4개의 튜플(Tuple)로 구성 : (Name, Value, Type, TTL) [TTL (Time To Live : 자원 레코드의 생존기간(자원이 캐시에서 제거되는 시간 결정)]
   - Type = A라면, Name은 호스트 이름이며 Value는 호스트 이름에 대한 IP 주소이므로, Type A 레코드는 표준 호스트 이름의 IP 주소 제공 (예) (```relay1.bar.foo.com```, 145.37.93.126, A))
   - Type = NS라면, Name은 도메인(```foo.bar```)이고, Value는 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 이름 (예) (```foo.com```, ```dns.foo.com```, NS))
   - Type = CNAME이면, Value는 별칭 호스트 이름 Name에 대한 정식 호스트 이름이며, 이 레코드는 질의 호스트에게 호스트 이름에 대한 정식 이름 제공 (예) (```foo.com```, ```relay1.bar.foo.com```, CNAME))
   - Type = MX라면, Value는 별칭 호스트 이름 Name을 갖는 메일 서버의 정식 이름 (예) ```foo.com```, ```mail.bar.foo.com```, MX))
     + MX 레콬드는 메일 서버의 호스트 이름이 간단한 별칭을 갖는 것 허용
     + 메일 서버의 정식 이름을 얻기 위해 DNS 클라이언트는 MX 레코드에 대한 질의를 하며, 다른 서버의 정식 이름을 얻기 위해서는 CNAME 레코드에 대한 질의를 함

3. 한 DNS 서버가 특별한 호스트 이름에 대한 책임 서버라면, 그 DNS 서버는 그 호스트에 대한 Type A 레코드를 포함
4. 서버가 호스트 이름에 대한 책임 서버가 아니라면, 그 서버는 호스트 이름을 포함하는 도메인에 대한 Type NS 레코드를 포함할 것이고, NS 레코드의 Value 필드에 DNS 서버의 IP 주소를 제공하는 Type A 레코드 포함
   - 예) ```gaia.cs.umass.edu```에 대한 책임 서버가 아닌 TLD 서버라고 가정
     + 서버는 호스트 ```gaia.cs.umass.edu```를 포함하는 도메인에 대한 레코드, 예를 들어 (```umass.edu```, ```dns.umass.edu```, NS)를 포함
     + TLD 서버 또한 Type A 레코드를 포함하는데, 이는 DNS 서버 ```dns.umass.edu```를 IP 주소(```dns.umass.edu```, 128.119.40.111, A)로 매핑

5. DNS 메세지
<div align="center">
<img src="https://github.com/user-attachments/assets/ee7ba6e2-3bd4-4874-b7aa-4ded2f4e6edb">
</div>

   - 처음 12바이트는 헤더 영역(Header Section)으로 여러 필드를 가지고 있음
     + 첫 필드는 질의를 식별하는 16비트 숫자 : 질의에 대한 응답 메세지에 복사되어, 클라이언트가 보낸 질의와 수신된 응답 간의 일치를 식별
     + 플래그 필드에는 여러 플러그 존재
       * 1비트의 질의/응답 플래그는 메세지가 질의(0)인지 응답(1)인지 구별
       * 1비트의 책임 플래그는 DNS 서버가 질의 이름에 대해 책임 서버일 때 응답 메세지에 설정
       * 1비트의 재귀 요구 플래그는 DNS 서버가 레코드를 갖지 않을 때 재귀적 질의 수행하기를 클라이언트(호스트 혹은 DNS 서버)가 원할 때 사용
       * 1비트의 재귀 가능 필드는 DNS 서버가 재귀 질의를 지원하면 응답에 설정
   - 헤더에는 4개의 개수 필드 존재하며, 데이터 영역의 4가지 타입의 발생 횟수
     + 질문 영역(Question Section) : 현재 질의에 대한 정보 포함 (질의되는 이름을 포함하는 이름 필드, 이름에 대해 문의되는 질의 타입을 나타내는 타입 필드)
     + 답변 영역(Answer Section) : DNS 서버로부터 원래 질의된 이름에 대한 자원 레코드를 포함 (각 자원 레코드에 Type, Value, TTL 존재)
       * 응답으로 여러 개의 RR을 보낼 수 있음 (호스트 이름은 여러 개의 IP 주소를 가질 수 있음)
     + 책임 영역(Authority Section) : 다른 책임 서버 레코드 포함
     + 추가 영역(Additionaal Section) : 도움이 되는 레코드 포함 (예) MX 질의에 대한 응답에서 응답 필드는 전자 메일 서버의 정식 호스트 이름을 제공하는 자원 레코드를 가지고 있는데, 추가 영역은 메일 서버의 정식 호스트 이름에 대한 IP 주소를 제공하는 Type A 레코드를 포함)
   - nslookup 프로그램 : DNS 질의를 하면 어떤 DNS 서버(루트 / TLD / 책임 서버)로 보낼 수 있는 프로그램으로, DNS 서버로부터 응답 메세지를 받은 후 응답에 있는 레코드를 화면에 사람이 읽을 수 있는 형태로 제시

6. DNS 데이터베이스에 레코드 삽입
   - 도메인 네임을 등록기관에 등록하는 것이 우선적
     + 등록 기관은 도메인 네임의 유일성 확인 및 그 도메인 이름을 DNS 데이터베이스에 넣고, 서비스에 대한 요금을 지불
     + 등록기관에 등록할 때는 등록 기관에 대해 주책임 서버와 부책임 서버의 이름과 IP 주소를 등록기관에 제공해야 함
   - 예) 이름과 IP 주소 : ```dns1.networkutopia.com```, ```dns2.networkutopia.com```, ```212.212.212.1```, ```212.212.212.2```
     + 이 두 책임 DNS 서버에 각각에 대해 등록 기관은 Type NS와 Type A 레코드가 TLD com 서버에 등록되도록 확인
     + 특히 ```networkutopia.com```에 대한 주책임 서버의 경우, 등록기관은 2개의 자원 레코드를 DNS 시스템에 삽입

<div align="center">
<img src="https://github.com/user-attachments/assets/19e47e3a-3b8d-4adb-a490-68ea31380e38">
</div>

  - 웹 서버 ```www.networkutopia.com```에 대한 Type A 자원 레코드와 메일 서버 ```mail.networkutopia.com```에 대한 Type MX 자원 레코드가 책임 DNS에 등록
  - 과거에는 정적으로 설정해야 했으나, 최근에는 동적으로 추가 혹은 삭제할 수 있도록 DNS 프로토콜에 UPDATE 선택사양 추가
  - 클라이언트 호스트는 먼저 DNS 질의를 자신의 로컬 DNS 서버로 보내고, 로컬 DNS 서버는 TLD com 서버에 접속 (로컬 DNS 서버는 TLD com 스타일 서버 주소가 캐싱되어 있지 않으면 루트 DNS 서버로 접속)
    + 이 TLD 서버는 나열된 Type NS와 Type A 자원 레코드를 가지고 있으므로, TLD com 서버는 로컬 DNS 서버로 두 자원 레코드를 포함하는 응답을 보냄
    + 로컬 DNS 서버는 ```www.networkutopia.com```에 대응하는 Type A 레코드를 요구하는 DNS 질의를 ```212.212.212.1```에게 보내면, 레코드는 요구하는 웹 서버, 즉 ```212.212.71.4```의 IP 주소를 제공
    + 로컬 DNS 서버는 호스트에게 이 레코드를 전달하며, 브라우저는 이 IP 주소로 호스트로 TCP 연결을 초기화하고, 그 연결로 HTTP 요청을 보냄

-----
### DNS 취약점
-----
1. DNS 서버에 대한 DDoS 대역폭 플러딩 공격
   - 공격자는 다량의 패킷을 각 DNS 루트 서버로 보내려는 시도를 하여 정상적으로 많은 DNS 질의들이 응답을 받을 수 없게 함
   - 공격자들은 가공의 네트워크(봇넷(Botnet))를 이용하여 13개의 DNS 루트 서버 각각으로 많은 양의 ICMP 핑(Ping) 메세지를 전송
   - 그러나 많은 DNS 루트 서버들은 루트 서버로 향하는 모든 ICMP 핑 메세지를 블록하도록 형상화한 패킷 필터로 보호
   - 대부분의 로컬 DNS 서버들은 최상위 도메인 서버들의 IP 주소를 캐싱하고 있어서, 질의 과정에서 자주 DNS 루트 서버를 거치지 않고(우회하고) 서비스할 수 있도록 허용
   - 좀 더 효과적인 DDoS 공격 : .com 도메인을 다루는 모든 TLD 서버에게 다량의 DNS 질의를 보내는 것
     + DNS 서버로 향하는 DNS 질의들을 필터링하기 어렵고, 루트 서버처럼 우회하기 쉽지 않음

2. 중간자 공격(Man-in-the-Middle Attack) : 공격자는 호스트로부터 질의를 가로채어 가짜 응답 반환
3. DNS 중독(Poisoning) 공격 : 공격자는 DNS 서버로 가짜 응답을 보내어 그 서버가 자신의 캐시에 가짜 레코드를 받아들이도록 속임수를 사용
4. 예방 방법 : DNS 보안 확장 프로토콜 개발하여 사용 (DNSSEC(DNS Security Extensions)는 DNS의 보안 확장 버전이며 인터넷에서 일반화)
