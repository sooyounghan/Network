-----
### 네트워크 애플리케이션 구조
-----
1. 네트워크 애플리케이션을 위한 통신은 종단 시스템 간 애플리케이션 계층에서 발생
<div align="center">
<img src="https://github.com/user-attachments/assets/03eb9195-4ad2-4605-a60d-2b74e2874d07">
</div>

2. 네트워크 구조는 고정되어 있지만, 애플리케이션 구조는 애플리케이션 개발자가 설계하며 다양한 종단 시스템에서 어떻게 조직되어야 하는지 알려줌
   - 클라이언트 - 서버 구조
   - P2P 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/f49d5029-a7f9-4691-91df-5131f7bd6b1f">
</div>

3. 클라이언트-서버 구조 (Client-Server Architecture)
   - 서버는 항상 동작하고 있는 호스트로서, 클라이언트라는 다른 호스트로부터 서비스 요청을 받음
   - 예) 클라이언트 호스트에서 실행되는 브라우저에서 웹 서버로 서비스를 요청하는 웹 애플리케이션 구조로, 웹 서버가 클라이언트 호스트로부터 객체를 요청받으면 웹 서버는 요청된 객체를 클라이언트 호스트로 보내면서 응답
   - 클라이언트는 서로 직접 통신하지 않음 (즉, 웹 애플리케이션에서는 2개의 브라우저가 직접 통신하지 않음)
   - 서버가 고정 IP 주소라는 잘 알려진 주소를 가짐
   - 서버는 항상 동작하므로 클라이언트는 서버 주소로 패킷을 보내 언제든지 서버에 연결할 수 있음
   - 하나의 서버 호스트가 자신의 클라이언트로부터 오는 모든 요청을 응답하는 것은 불가능하므로, 많은 수의 호스트를 갖춘 데이터 센터가 가상의 서버를 생성하는 역할로 사용

4. P2P (Peer-To-Peer) 구조
   - 애플리케이션은 피어(Peer)라는 간혈적으로 연결된 호스트 쌍이 직접 통신하며, 항상 켜져 있는 인프라스트럭쳐 서버에 최소로 의존하거나 의존하지 않음
   - 피어는 서비스 제공자가 소유하지 않고 사용자들이 제어하는 데스크톱과 랩탑이며, 특정 서버를 통하지 않고 피어가 통신
   - 자기 확장성(Self-Scalability)을 가짐 : 각 피어들이 요청하면 작업 부하를 만들어내지만 각 피어들은 또한 다른 피어들에게 분배함으로 그 시스템에 서비스 능력을 추가
   - 비용도 효율적 (상당한 서버 인프라스트럭쳐와 서버 대역폭을 요구하지 않기 떄문임)

-----
### 프로세스 간 통신
-----
1. 운영체제에서 실제로 통신하는 것은 프로세스(Process)
   - 종단 시스템에서 실행되는 프로그램으로, 통신 프로세스가 같은 종단 시스템에서 실행될 때 그들은 서로 프로세스 간 통신
   - 따라서, 프로세스 간 통신을 위한 규칙은 종단 시스템의 운영체제에 의해 좌우

2. 2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메세지(Message) 교환으로 서로 통신
   - 송신 프로세스는 메세지를 만들어 네트워크로 보내면, 수신 프로세스는 메세지를 받고 역으로 메세지를 보내 응답

3. 클라이언트와 서버 프로세스
   - 웹 애플리케이션에서 클라이언트 브라우저 프로세스는 웹 서버 프로세스와 메세지를 교환하며, P2P 파일 공유 서비스에서는 한 피어의 프로세스에서 다른 피어의 프로세스로 파일 전송
   - 즉, 웹에서 브라우저는 클라이언트 프로세스이며 웹 서버는 서버 프로세스 / P2P 파일 공유에서는 파일을 내려받는 피어가 클라이언트이며 파일을 올리는 피어가 서버
   - 💡 클라이언트 : 두 프로세스 간 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스
   - 💡 서버 : 세션을 시작하기 위해 접속을 기다리는 프로세스

4. 프로세스와 컴퓨터 네트워크 사이 인터페이스
   - 프로세스는 소켓(Socket)을 통해 네트워크로 메세지를 보내고 받음
<div align="center">
<img src="https://github.com/user-attachments/assets/9a4c0873-a977-405c-bc7a-cb64e3e34be5">
</div>

   - 소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
   - 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, 애플리케이션과 네트워크 사이 API(Application Programming Interface)
   - 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만, 소켓의 트랜스포트 계층에 대해서는 통제권을 거의 갖지 못함 (트랜스포트 프로토콜 선택, 최대 버퍼 및 최대 세그먼트 크기 같은 트랜스포트 계층 매개변수 설정만 가짐)

5. 프로세스 주소 배정
   - 한 호스트 상 수행되고 있는 프로세스가 패킷을 다른 호스트에서 수행되고 있는 프로세스로 패킷을 보내기 위해 수신 프로세스 주소를 알아야 함
   - 수신 프로세스를 식별하기 위한 정보
      + 호스트의 주소
      + 그 목적지 호스트 내의 수신 프로세스를 명시하는 식별자
   - 인터넷에서는 호스트를 IP 주소로 식별 (32비트로 구성하며 호스트를 유일하게 식별)
   - 수신 프로세스 식별을 위해서 목적지 포트 번호(Port Number)를 사용
   - 인기 있는 애플리케이션의 경우 특정 포트 번호 할당 (웹 서버 : 80, SMTP : 25 등) - 포트 번호 목록 : ```http://www.iana.org```

-----
### 애플리케이션이 이용 가능한 트랜스포트 서비스
-----
1. 신뢰적 데이터 전송
   - 패킷들은 컴퓨터 네트워크 내에서 손실될 수 있음
   - 만약, 프로토콜이 보장된 데이터 전송 서비스를 제공하면, 이를 신뢰적 데이터 전송 (Reliable Data Transfer)
   - 트랜스포트 계층 프로토콜이 신뢰적 데이터 전송을 제공하지 않으면, 이를 손실 허용 애플리케이션(Loss-Tolerant Application)이라 하며, 어느 정도 데이터 손실을 허용 (실시간 및 저장 오디오 / 비디오 같은 멀티미디어 애플리케이션에서 사용)

2. 처리율
   - 네트워크 경로를 따라 두 프로세스 간 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
   - 대역폭을 공유하고, 세션들이 발생 및 소멸하므로 가용한 처리율은 시간에 따라 변동
   - 트랜스포트 프로토콜은 어느 명시된 속도에서 보장된 가용 처리율을 제공 가능
     + r비트 / 초의 보장된 처리율을 요구하면, 트랜스포트 프로토콜은 가용한 처리율이 적어도 항상 r bps임을 보장
   - 처리율 요구사항을 갖는 애플리케이션 : 대역폭 민감 애플리케이션 (Bandwidth-Sensitive Application)
   - 처리율 요구사항을 가지지 않는 애플리케이션 : 탄력적 애플리케이션 (Elastic Application)

3. 시간
   - 트랜스포트 계층 프로토콜은 시간 보장(Timing Guarantee)을 제공 가능하여, 실시간 상호작용 애플리케이션에 유용하지만, 데이터 전송에 엄격한 시간 제한이 요구
   - 비실시간 애플리케이션의 경우 낮은 지연보다 항상 높은 지연이 선호되지만, 종단 간 지연에 엄격한 제한은 받지 않음

4. 보안
   - 하나 이상의 서비스 제공 가능
   - 데이터가 송신과 수신 프로세스에서 어느 정도 관찰되더라도 두 프로세스 사이에 기밀성 제공 가능
   - 또한, 기밀성(Confidentiality) 외에도 무결성(Integrity)와 종단 인증(Authentication) 등 포함
