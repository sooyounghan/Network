-----
### GBN (Go-Back-N) 프로토콜
-----
1. 송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송(가능할 때)할 수 있음
   - 그러나 파이프라인에서 확인 응답이 안 된 패킷의 최대 허용 수 N보다 크지 않아야 함

2. GBN 프로토콜에서 송신자 관점의 순서 번호
<div align="center">
<img src="https://github.com/user-attachments/assets/7da8a5e9-c997-4b53-8b28-2694eab9adba">
</div>

  - base : 확인 응답이 안 된 가장 패킷의 순서 번호
  - nextseqnum : 사용되지 않은 가장 작은 순서 번호 (전송될 다음 패킷의 순서 번호)
  - 순서 번호의 범위에서 4개의 간격 식별 가능
    + [0, base - 1] : 순서 번호는 이미 전송되고 확인 응답이 된 패킷
    + [base, nextseqnum - 1] : 송신은 되었지만, 아직 확인 응답 되지 않은 패킷
    + [nextseqnum, base + N - 1] : 상위 계층으로부터 데이터가 도착하면 바로 전송될 수 있는 패킷을 위해 사용
    + [base + N, ...] : 파이프라인에서 확인 응답이 안 된 패킷(순서 번호 base를 가진 패킷)의 확인응답이 도착할 때까지 사용할 수 없음
  - N : 아직 확인 응답이 안 된 패킷을 위해 사용할 수 있는 순서 번호의 범위로서, 순서 번호 범위 상 크기가 N인 윈도인 윈도 크기
  - 프로토콜이 동작할 때, 이 윈도는 순서 번호 공간에서 오른쪽으로 이동 (Slide)
  - 따라서, GBN 프로토콜은 슬라이딩 윈도 프로토콜(Sliding-Window Protocol)

3. N값 제한 이유
   - 실제 패킷 순서 번호는 패킷 헤더 안 고정된 길이 필드에 포함
   - 만약, $k$가 패킷 순서 번호의 필드의 비트 수라면, 순서 번호의 범위는 [0, $2^{k} - 1$]
     + 순서 번호의 제한된 범위에서, 순서 번호를 포함하는 모든 계산은 Modulo $2^{k}$ 연산을 이용 (순서 번호 $2^{k} - 1$ 다음에 0이 옴)
   - rdt 3.0은 1비트의 순서 번호 필드를 가지므로, [0, 1]의 순서 번호를 가지며, TCP는 32비트 순서 번호 필드를 가짐 (TCP 순서 번호는 패킷 단위라기보다 바이트 스트림에서 바이트를 세는 수)

4. ACK 기반의 NAK가 없는 GBN 프로토콜의 송신 측과 수신 측의 확장된 FSM
<div align="center">
<img src="https://github.com/user-attachments/assets/bf13aeb1-f057-4104-bccd-b1d27b4d531e">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/8dd1e65c-634f-4c42-a3b4-ecc46bdd1f10">
</div>

   - base와 nextseqnum 변수를 추가, 이러한 변수에서의 동작과 이러한 변수를 포함하는 조건부 동작 추가

5. GBN 송신자는 3가지 타입 이벤트에 반응
   - 상위로부터의 호출
     + rdt_send()가 위로부터 호출되면, 송신자는 송신자는 우선 윈도가 가득찼는지, 즉 N개의 아직 확인 응답되지 않은 패킷이 있는지 확인
     + 만약, 윈도가 가득 차 있지 않다면 패킷이 생성되고 송신되고, 변수들이 적절하게 갱신
     + 윈도가 가득 차있다면, 송신자는 윈도가 가득 차 있음을 가리키는 함축적 의미로 단지 데이터를 상위 계층으로 반환하며, 상위 계층은 나중에 다시 시도
     + 실제 구현에서는 데이터를 버퍼링(즉시 송신하지 않음) 또는 오직 윈도가 가득 차 있지 않을 때만 rdt_send()를 호출하는 동기화 메커니즘 (세마포어(Semaphore) 또는 플래그 등) 사용

   - ACK의 수신
     + GBN 프로토콜에서 순서 번호 n을 가진 패킷에 대한 확인 응답은 누적 확인 응답(Cumulative Acknowledgement)로 인식
     + 누적 확인 응답은 수신 측에서 올바르게 수신된 n을 포함하여, n까지의 순서 번호를 가진 모든 패킷에 대한 확인 응답

   - 타임아웃 이벤트
     + 손실이 있거나 아주 긴 지연된 패킷이 있을 때의 송신자 동작으로부터 유래된 이름이 GBN 프로토콜
     + 전송 후 대기 프로토콜과 같이, 타이머는 손실된 데이터 또는 손실된 확인응답 패킷으로부터 회복하는데 사용
     + 만약, 타임아웃이 발생하면 송신자는 이전에 전송되었지만 아직 확인응답되지 않은 모든 패킷을 다시 송신
     + 즉, 송신자는 가장 오래된 전송했으나 아직 확인응답되지 않은 패킷에 대한 타이머로 단일 타이머를 사용하며, 만일 한 ACK가 수신되었으나 추가로 전송했지만 아직 확인응답이 되지 않은 패킷이 존재한다면, 타이머는 다시 시작하며, 아직 확인 응답이 안 된 패킷이 없다면, 타이머는 멈춤

6. GBN에서 수신자의 행동
   - 만약 순서 번호 n을 가진 패킷이 오류 없이, 그리고 순서대로 수신(즉, 상위 계층에 마지막으로 전달된 데이터가 순서 번호 n - 1을 가진 패킷에서 온 것이라면), 수신자는 패킷 n에 대한 ACK를 송신하고 상위 게층에 패킷의 데이터 부분 전달
   - 그 외의 경우에는 수신자는 그 패킷을 버리고, 가장 최근에 제대로 수신된 순서의 패킷에 대한 ACK를 제공
   - 패킷이 상위 계층에 한 번에 하나씩 전송되므로, 만일 패킷 k가 수신되고 상위 계층에 전달되었다면, 이미 k보다 낮은 순서 번호를 가진 모든 패킷 또한 전달되었음을 의미

7. GBN 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버림
   - 만약 패킷 n이 수신되어야 하지만, 그 다음 패킷 n + 1이 먼저 도착했다고 가정
   - 데이터가 순서대로 전달되어야 하므로, 수신자는 패킷 n + 1을 저장하고 나중에 패킷 n이 수신되고 전달된 후 상위 계층에 이 패킷을 전달
   - 그러나 만일 패킷 n이 손실된다면 송신자에게 GBN 재전송 규칙에 따라 패킷 n과 n + 1이 모두 재전송될 것
   - 즉, 수신자는 어떤 순서가 잘못된 패킷에 대해 버퍼링할 필요가 없음
   - 송신자는 윈도 상위와 하위 경계에 있는 이 윈도 안에 nextseqnum 위치를 유지해야 하지만, 수신자가 유지해야 하는 것은 다음 순서의 패킷 번호 (수신자 FSM에서의 변수 expectedseqnum에서 유지)
   - 올바르게 수신된 패킷을 버리는 것의 단점은 그 패킷의 재전송이 손실되거나 왜곡될 수 있으므로, 많은 재전송이 필요할 수 있음

8. 윈도 크기가 4패킷인 경우 GBN 프로토콜의 동작
<div align="center">
<img src="https://github.com/user-attachments/assets/7a403e73-bc0f-49f5-b7e6-e713e180bfad">
</div>

   - 이 윈도 크기의 제한으로 송신자는 패킷 0부터 3까지 송신
   - 그러나 송신을 계속 하기 전 하나 이상의 패킷이 긍정 확인응답되는 것을 기다려야 함
   - 각 성공적인 ACK(예) ACK0, ACK1 등)가 수신되었을 때, 윈도는 앞으로 이동하고 송신자는 하나의 새로운 패킷(pkt4, pkt5 ..)을 전송
   - 수신 측에서는 패킷 2가 손실되었으므로 패킷 3, 4, 5는 순서가 잘못된 패킷으로 발견되어 제거
