-----
### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송 : rdt 3.0
-----
1. 하위 채널이 패킷을 손실하는 경우
   - 송신자에게 손실된 패킷의 검출과 회복 책임을 부여해야 함
   - 송신자가 데이터 패킷을 전송하고 패킷 또는 수신자의 패킷에 대한 ACK를 손실했다고 가정
     + 어느 경우에서나 송신자에게는 수신자로부터 어떠한 응답이 없음
     + 만약 송신자가 패킷을 잃어버렸다고 확신할 정도로 충분한 시간을 기다릴 수 있다면, 데이터 패킷은 간단하게 재전송될 수 있음
     + 송신자는 적어도 송신자와 수신자 사이의 왕복 시간 지연 (중간 라우터에서의 버퍼링 포함)에 수신 측에서 패킷을 처리하는 데 필요한 시간만큼 기다림
     + 하지만, 이상적으로 프로토콜이 패킷 손실을 가능한 빨리 복구해야 함
     + 따라서, 만일 ACK가 이 시간 안에 수신되지 않는다면 패킷은 재전송되도록 해야 함
     + 만일, 패킷이 유별나게 큰 지연을 갖는다면, 송신자는 비록 데이터 패킷이나 그 패킷에 대한 ACK이 손실되지 않았더라도 패킷을 재전송할 수 있음 (송신자 대 수신자 채널에서 중복 데이터 패킷의 가능성 포함)

   - 송신자는 데이터 패킷이 손실되었는지, ACK가 소실되었는지, 패킷 또는 ACK가 단순히 지나치게 지연된 것인지 알지 못하므로, 주어진 시간이 지난 후 송신자를 인터럽트(중단)할 수 있는 카운트다운 타이머가 필요
     + 매 패킷(첫 번째 또는 재전송 패킷)이 송신된 시간에 타이머를 시작
     + 타이머 인터럽트에 반응 (적당한 행동 취함)
     + 타이머를 멈춤

2. 패킷이 손상되거나 손실될 수 있는 채널에서 데이터를 신뢰적으로 전송하는 프로토콜인 rdt 3.0에 대한 송신자 FSM
<div align="center">
<img src="https://github.com/user-attachments/assets/26102668-7059-403d-82b3-e43d7d3c2d85">
</div>

<div align="center">
<img src="https://github.com/user-attachments/assets/d86010fb-1e17-4310-b01c-3548f9d176e4">
</div>

  - 패킷에 대한 수신 시간은 전송 지연과 전파 지연 때문에 패킷 전송 시간보다 더 늦음
  - 패킷의 순서 번호가 0과 1이 번갈아 일어나므로, 프로토콜 rdt 3.0은 얼터네이팅 비트 프로토콜(Alternation-Bit Protocol)이라 부름

-----
### 파이프라이닝된 신뢰적인 데이터 전송 프로토콜
-----
1. rdt 3.0의 핵심적인 성능 문제 : rdt 3.0이 전송 후 대기(Stop-And-Wait) 프로토콜
<div align="center">
<img src="https://github.com/user-attachments/assets/70e1f5a3-c8a7-4e20-885b-47f0d3532e7e">
</div>

   - 하나의 호스트는 미국 서부에 위치, 하나는 동부에 위치한 두 종단 호스트의 경우
     + 종단 시스템 사이의 광속 왕복 전파 지연(RTT) : 대략 30ms
     + 두 호스트가 1 Gbps 전송률(R)을 가진 채널로 연결되었다고 가정
     + 헤더 필드와 데이터를 모두 포함하여, 패킷 당 1,000바이트 (8,000 비트)의 패킷 크기(L)를 가지고 1 Gbps 링크로 패킷을 실제 전송하는데 필요한 시간
<div align="center">
<img src="https://github.com/user-attachments/assets/2d399e6c-b305-43c1-9c83-22536f5488a6">
</div>

   - 전송 후 대기 프로토콜을 가지고 송신자가 t = 0에서 데이터를 전송 시작한다면, t = 8 ㎲에서 마지막 비트가 송신측 채널로 들어감
   - 패킷은 15 ms 동안 대륙 횡단 후, t = RTT/2 + L/R = 15.008 ms에 수신 측에 마지막 비트가 도착
   - ACK 패킷은 매우 작은 크기 (전송 시간 무시 가능)이고, 수신자는 데이터 패킷의 마지막 비트가 수신되자마자 ACK 패킷을 송신하기 시작할 수 있다고 가정
   - 송신자 측에 ACK 패킷은 t = RTT + L/R = 30.008 ms 후에 다시받을 수 있음
   - 송신자가 채널을 통해 (성공적으로 비트를 전송하는데 걸린 전체 시간에 대한) 실제 비트를 전송하는 데 걸리는 시간을 송신자 (또는 채널)의 이용률(효율)을 수식으로 정의하면,
<div align="center">
<img src="https://github.com/user-attachments/assets/0d3fe7ff-4a11-425c-b277-48009e8cbf16">
</div>

   - 송신자는 단지 시간의 0.0027%만 바빴으며, 30.008ms 동안 1,000바이트를 송신할 수 있지만, 비록 초당 1 Gbps가 가용하다고 하더라도 267 kbps의 유효 처리량을 가짐
   - 송신자와 수신자 사이 중간 라우터에서 발생하는 처리 지연 및 큐잉 지연과, 송신자와 수신자에서의 하위 계층 프로토콜 처리 시간은 무시 (이를 포함하면 지연이 더욱 증가하고 나쁜 성능이 두드러지게 됨)
<div align="center">
<img src="https://github.com/user-attachments/assets/b3769e17-0baa-4e26-a5a1-a872b9f4847c">
</div>

   - 해결책 : 확인 응답을 기다리지 않고, 여러 패킷을 전송하도록 허용
     + 전송 중인 송신자-수신자 패킷을 파이프라인에 채워 넣음으로써 나타낼 수 있는데, 이를 파이프라니이(Pipelining)이라고 함
     + 신뢰적인 데이터 전송 프로토콜에서의 중요성
       * 순서 번호 범위가 커져야 함 : 각 전송중인 패킷(재전송은 미고려)은 유일한 순서 번호를 가져야 하고, 전송 중인 확인 응답(ACK)이 안 된 패킷이 여럿 있을지도 모름
       * 프로토콜 송신 측과 수신 측은 패킷 하나 이상을 버퍼링 : 최소한 송신자는 전송되었으나 확인 응답되지 않은 패킷을 버퍼링해야 함
       * 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷, 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려있는데, 파이프라인 오류 회복의 두 가지 기본적 접근 방법 : GBN(Go-Back-N, N부터 반복)과 SR(Selective Repeat, 선택적 반복) 등 존재
       
