-----
### SR
-----
1. GBN 자체 성능 문제 : 윈도 크기와 대역폭 지연 곱의 결과가 모두 클 때, 많은 패킷이 파이프라인에 있을 수 있으며, GBN은 패킷 하나의 오류로 많은 패킷을 재전송하므로, 많은 패킷을 불필요하게 재전송하는 경우 발생
   - 채널 오류의 확률이 증가할 수록, 파이프라인은 불필요한 재전송 데이터로 채워짐

2. SR(Selective Repeat, 선택적 반복) 프로토콜은 수신자에서 오류(손실 또는 변조)가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송을 피함
   - 필요에 따라 각 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 개별적인 확인 응답 요구
   - 윈도 크기 N은 파이프라인에서 아직 확인응답이 안 된 패킷 수를 제한하는 데 사용
   - 하지만, GBN과 달리 송신자는 윈도에 있는 몇 패킷에 대한 ACK를 이미 수신했을 것

<div align="center">
<img src="https://github.com/user-attachments/assets/5c3d84fe-7b6d-48ae-a022-15d952e9ec91">
</div>

  - 순서 번호 공간에 대한 SR 송신자와 수신자 관점
  - SR 송신자의 이벤트와 행동
    + 상위로부터 데이터 수신
      * 상위에서 데이터가 수신될 때, SR 송신자는 패킷의 다음 순서 번호를 검사
      * 순서 번호가 송신자 윈도 내 있으면 데이터는 패킷으로 송신
      * 그렇지 않으면 GBN처럼 버퍼에 나중에 전송하기 위해 되돌려짐

    + 타임아웃
      * 타이머는 손실된 패킷을 보호하기 위해 재사용
      * 그러나 타임아웃 시 오직 한 패킷만이 전송되기 대문에, 각 패킷은 자신의 논리 타이머가 있어야 하며, 하나의 하드웨어 타이머가 여러 개 논리 타이머를 흉내 내는 데 사용

    + ACK 수신
      * ACK가 수신되었을 때, SR 송신자는 그 ACK가 윈도 내에 있다면 그 패킷을 수신된 것으로 표시
      * 만약, 패킷 순서 번호가 send_base와 같다면, 윈도 베이스는 가장 작은 순서 번호를 가진 아직 확인응답되지 않은 패킷으로 옮겨짐
      * 만약, 윈도가 이동하고 윈도 내 순서 번호를 미전송 패킷이 있다면, 이 패킷들을 전송

  - SR 수신자의 이벤트와 행동
    + [rcv_base, rcv_base + N - 1] 내 순서 번호를 가진 패킷이 손상 없이 수신
      * 수신된 패킷이 수신자의 윈도에 속하는 것이므로, 선택적인 ACK 패킷이 송신자에게 회신
      * 만약, 이 패킷이 이전에 수신되지 않은 것이라면 버퍼에 저장
      * 만약, 이 패킷이 수신 윈도(rcv_base)의 base와 같은 순서 번호로 가졌다면, 이 패킷과 이전에 버퍼에 저장되어 연속적으로 번호를 가진(rcv_base로 시작하는) 패킷들은 상위 게층으로 전달
      * rcv_base = 2의 순서 번호를 가진 패킷이 수신되면, 이 패킷과 3, 4, 5 패킷이 상위 계층으로 전달될 수 있음

    + [rcv_base - N, rcv_base - 1] 내 순서 번호를 가진 패킷이 수신
      * 💡 이 패킷이 수신자가 이전에 확인응답 한 것일지라도 ACK가 생성되어야 함 (즉, 수신자가 현재 base보다 작은 특정 순서 번호를 가진 이미 수신된 패킷을 무시하지 않고 재확인 응답을 함)
      * 수신자가 이 패킷에 대해 확인 응답을 하지 않는다면, 송신자의 윈도는 앞으로 이동하지 않음
        
    + 그 외의 경우, 패킷 무시

  - SR 수신자는 패킷의 순서와 무관하게 손상 없이 수신된 패킷에 대해 확인응답을 할 것
    + 순서가 바뀐 패킷은 빠진 패킷(아직 도착하지 않은 더 낮은 순서 번호를 가진 패킷)이 수신될 때까지 버퍼에 저장하고, 빠진 패킷이 수신된 시점에 일련의 패킷을 순서대로 상위 계층에 전달

3. SR 동작의 예
<div align="center">
<img src="https://github.com/user-attachments/assets/34766e5a-338e-41cf-b425-388dc985072c">
</div>

  - SR 프로토콜에서 송신자와 수신자의 윈도는 항상 같지 않음
  - 송신자와 수신자 윈도 사이의 동기화 부족은 순서 번호의 한정된 범위일 때 발생
    + 한정된 범위의 네 패킷 순서 번호 0, 1, 2, 3과 윈도 크기 3일 때의 예시
    + 0부터 2까지의 패킷이 전송되어 올바로 수신되고, 수신자에게서 확인이 되었다고 가정
    + 그 순간 수신자의 윈도는 각 순서 번호가 3, 0, 1인 4, 5, 6번째 패키에 있음
      * (a) : 처음 3개의 패킷에 대한 ACK가 손실되고, 송신자는 이 패킷을 재전송하고, 수신자는 순서 번호가 0인 패킷(처음 보낸 패킷 복사본)을 수신
      * (b) : 처음 3개 패킷에 대해 ACK가 올바르게 모두 전달되고, 송신자는 자신의 윈도를 앞으로 이동시켜 순서 번호가 3, 0, 1인 4, 5, 6번째 패킷을 보내는데, 이 때, 순서 번호 0을 가진 패킷(새로운 데이터 포함 패킷)은 도착
      * 모든 수신자는 채널을 통해 받고, 채널을 통해 보내는 메세지 순서를 관찰하는데, 다섯 번째 패킷의 원래 전송과 첫 번째 패킷의 재전송을 구별할 방법이 없음 (0인 패킷)
    + 💡 따라서, 최소한의 윈도 크기는 SR 프로토콜에 대한 순서 번호 크기의 절반보다 작거나 같아야 함

4. 신뢰적인 데이터 전송 메커니즘과 그 사용에 대한 요약
<div align="center">
<img src="https://github.com/user-attachments/assets/cbf2756d-eb10-4ee3-92a8-9fe7ac0c3839">
</div>

  - 송신자와 수신자를 연결하는 채널이 네트워크라면, 패킷 순서 바뀜이 일어날 수 있음
  - 즉, 패킷 순서 바뀜 현상으로, 송신자와 수신자의 윈도가 $x$를 포함하지 않고 있더라도, 순서 번호 또는 확인 응답 번호 $x$를 가진 오래된 패킷의 복사본들이 생길 수 있음
  - 패킷 순서가 바뀌는 채널이라는 것은 본질적으로 버퍼에 저장하고 나중에 어느 때나 이 패킷들을 임의로 내보낸다고 간주할 수 있음
  - 순서 번호가 재사용될 수 있는 문제로 중복된 패킷들을 막을 수 있는 조치에 대한 실제 방식 : 송신자가 이전에 송신된 순서 번호 $x$를 가진 패킷들이 더 이상 네트워크에 없음에 어느 정도 확신할 때 까지 순서 번호가 재사용되지 않음을 확실히 하는 것
    + 즉, 패킷이 어느 일정 시간 이상으로 네트워크에서 존재할 수 없다는 가정에 의해 이루어짐
    + 대략 3분의 최대 패킷 수명이 고속 네트워크에 대한 TCP 확장에 가정
  
