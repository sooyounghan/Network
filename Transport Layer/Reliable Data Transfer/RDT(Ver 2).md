-----
### 비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송 : rdt 2.0
-----
1. 패킷 안의 비트들이 하위 채널에서 손상되는 모델 (패킷이 전송 또는 전파되거나 버퍼링될 때 네트워크 물리적 구성요소에서 비트 오류가 일반적으로 발생)
   - 전송된 모든 패킷이 송신된 순서대로 (패킷 비트가 손상된다 할지라도) 수신된다고 가정

2. 메세지 받아쓰기 프로토콜에서는 긍정 확인 응답(Positive Acknowledgement, OK)과 부정 확인 응답 (Negative Acknowledgement)을 둘 다 사용 : 정확하게 수신 또는 잘못 수신되어 반복이 필요한지 수신자가 송신자에게 알려줌
   - 컴퓨터 네트웤 설정에서 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 자동 재전송 요구(Automatic React reQuest, ARQ) 프로토콜

3. 비트 오류 처리를 위한 세 가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구
   - 오류 검출
     + 비트 오류가 발생했을 때, 수신자가 검출할 수 있는 기능 필요
     + UDP는 이러한 목적을 위해 인터넷 체크섬 필드 사용
     + 수신자가 패킷 비트 오류를 검출하고 복구할 수 있게 해주며, rdt 2.0 데이터 패킷의 패킷 체크섬 필드에 구성

   - 수신자 피드백
     + 각기 다른 종단 시스템에 동작하므로, 송신자가 수신자의 상태(패킷이 정확히 수신 또는 아님)를 알기 위한 유일한 방법은 수신자가 송신자에게 피드백 제공
     + 메세지 명령 시나리오에서 긍정 확인 응답(ACK)과 부정 확인 응답(NAK)
     + rdt 2.0 프로토콜은 수신자로부터 송신자 쪽으로 ACK와 NAK 패킷들을 전송하며, 이러한 패킷은 단지 한 비트 길이면 됨 (0 값은 NAK, 1 값은 ACK을 가리킬 수 있음)

   - 재전송 : 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송

4. rdt 2.0의 FSM
<div align="center">
<img src="https://github.com/user-attachments/assets/334f9468-a79b-43ef-9194-36cd22b9ef39">
</div>

   - rdt 2.0 송신 측은 2개의 상태를 가짐
     + 가장 왼쪽 상태에서 송신 측 프로토콜은 상위 계층으로 데이터가 전달되기를 기다림
     + rdt_send(data) 이벤트가 발생하면, 송신자는 패킷 체크섬과 함께 학께 전송될 데이터를 포함하는 패킷(sndpkt)을 생성하고, 그 패킷을 udt_send(sndpkt) 동작을 통해 전송
     + 가장 오른쪽 상태에서 송신자 프로토콜은 수신자로부터의 ACK 또는 NAK 패킷을 기다림
       * ACK 패킷이 수신되면(= rdt_rcv(rcvpkt) && isACK(rcvpkt)) 송신자는 가장 최근에 최송된 패킷이 정확하게 수신되었음을 알 수 있음
       * 💡 NAK 패킷이 수신되면, 프로토콜은 마지막 패킷을 재전송하고 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK 또는 NAK을 기다림
     + 💡 송신자가 ACK 또는 NAK를 기다리는 상태에 있을 때, 상위 계층으로부터 더 이상 데이터를 받을 수 없음 (rdt_send(data) 이벤트 발생 불가) : 송신자가 ACK를 수신하고 이 상태를 떠난 후에 발생 가능
     + 따라서, 송신자는 수신자가 현재 패킷을 정확하게 수신했음을 확실하기 전까지 새로운 데이터를 전달하지 않음
     + 이러한 행동 때문에 이를 전송 후 대기(Stop-And-Wait) 프로토콜이라 함

   - rdt 2.0 수신 측은 단일 상태를 가짐
     + 패킷이 도착했을 때, 수신자는 수신된 패킷이 손상되었는지 아닌지에 따라 ACK 또는 NAK로 응답 (= rdt_rcv(rcvpkt) && corrupt(rcvpkt)는 패킷이 수신되고 오류가 검출되는 이벤트에 대응)

   - 문제점 : ACK 패킷 또는 NAK 패킷이 손상될 가능성을 고려하지 않음
     + 따라서, 오류를 검출하기 위해 ACK와 NAK 패킷에 대한 체크섬 비트 추가 필요
     + 또한 ACK 또는 NAK 패킷을 오류로부터 복구하는 기능도 필요

5. 손상된 ACK 또는 NAK를 처리하기 위한 세 가지 가능성
   - 수신자가 송신자에 메세지를 이해하지 못하면, '무엇이라고 했는지'에 대한 응답을 할 것이며, 즉, 새로운 송신자-수신자 패킷을 도입
   - 송신자가 검출 뿐 아니라 비트 오류로부터 회복할 수 있는 충분한 체크섬 비트를 추가 (패킷이 손상될 수 있지만 손실되지 않는 채널의 경우 즉각 문제 해결 가능)
   - 송신자가 왜곡된 ACK 또는 NAK 패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신
     + 하지만, 이 방식은 송신자에서 수신자 간의 채널로 중복 패킷(Duplicate Packet) 전송
     + 중복 패킷의 가장 근본적인 어려운 점은 마지막으로 전송된 ACK 또는 NAK가 송신자에게 정확하게 수신되었는지 알 수 없음
     + 그러므로, 도착하는 패킷이 새로운 데이터를 포함하고 있는 것인지 재전송인지 알 수 없음

-----
### 비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송 : rdt 2.1
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/c26e04ad-59f5-4905-a9e3-1888f261bdac">
<img src="https://github.com/user-attachments/assets/3a835d76-539f-4da1-8b2a-9ff9b9f79d3b">
</div>

1. 해결책 : 데이터 패킷에 새로운 필드를 추가하고 이 필드 안에 순서 번호(Sequence Number) 삽입하는 방식
   - 데이터 패킷에 송신자가 번호를 붙이는 것으로, 수신자는 수신된 패킷이 재전송일지 결정할 때는 이 순서 번호만 확인하면 됨
   - 간단한 전송 후 대기 프로토콜의 경우, 한 비트 순서 번호이면 송신자가 이전에 전송된 패킷을 다시 전송한 것인지(수신된 패킷의 순서 번호는 가장 최근에 수신된 패킷과 같은 순서 번호를 가짐), 새로운 패킷(순서 번호가 변하면, Modulo 2 연산 진행)을 전송할 것인지를 충분히 알 수 있음
   - 송신자는 수신된 ACK와 NAK 패킷(왜곡인지 아닌지)에 가장 최근에 전송된 데이터 패킷에 대한 응답으로 발생한 것임을 암

2. rdt 2.1 송신자와 수신자 FSM은 전보다 두 배 많은 상태를 가지고 있음
   - 프로토콜 상태가 현재 (송신자에 의해) 전송되고 있거나, (수신자가) 기다리고 있는 패킷이 순서 번호 0 또는 1을 가져야 하는지 반영해야 하기 때문임
   - 0번 패킷이 송신되고 있거나 기다리고 있는 상태에서의 동작은 1번 패킷이 송신되고 있거나 기다리는 상태의 미러 이미지
   - 즉, 단지 순서 번호의 차이만 있을 뿐임
   - 수신자로부터 송신자까지의 긍정 확인 응답과 부정 확인 응답 모두 포함
     + 순서가 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대해 긍정 확인 응답을 전송
     + 💡 손상된 패킷이 수신되면, 수신자는 부정 확인 응답을 전송하는데, NAK를 전송하는데 대신 가장 최근에 정확하게 수신된 패킷에 대해 ACK를 송신함으로써 NAK를 송신한 것과 같은 효과를 얻음
     + 💡 같은 패킷에 대해 2개의 ACK를 수신한(중복 ACK 수신) 송신자는 수신자가 두 번 ACK 한 패킷의 다음 패킷을 정확하게 수신하지 못했다는 것을 알 수 있음

-----
### 비트 오류가 있는 채널 상에서의 신뢰적 데이터 전송 : rdt 2.2
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/9973645a-b3c7-44b4-b786-e972b442dd94">
</div>

1. rdt 2.2는 수신자가 반드시 ACK 메세지에 의해 확인 응답되는 패킷의 순서 번호를 포함해야 하는 것(수신자 FSM의 make_pkt()에 (ACK, 0) 또는 (ACK, 1)인 인수를 넣어 수행)
2. 송신자는 수신된 ACK 메세지에 의해 확인 응답된 패킷의 순서 번호를 반드시 점검 (송신자 FSM의 isACK()에 0 또는 1인 인수를 넣어 수행)
