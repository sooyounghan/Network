-----
### TCP 연결 관리
-----
1. 하나의 호스트(클라이언트)에서 운영되는 프로세스가 다른 호스트(서버) 안의 또 다른 프로세스와 연결을 시작하길 원한다고 가정
2. 먼저 클라이언트 애플리케이션 프로세스는 서버에 있는 프로세스와 연결 설정을 원한다는 것을 클라이언트 TCP에게 알림
3. 클라이언트 안의 TCP는 다음과 같은 방법으로 서버와 TCP 연결 설정
<div align="center">
<img src="https://github.com/user-attachments/assets/13a288b5-cf72-472d-91fd-734bf96b4544">
</div>

   - 1단계 : 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트 송신
     + 애플리케이션 계층 데이터를 포함하지 않지만, 세그먼트 헤더에 SYN 비트라고 불리는 하나의 플래그 비트를 1로 설정 (SYN 세그먼트)
     + 클라이언트는 최초의 순서 번호(client_isn)를 임의로 선택하고, 최초의 TCP SYN 세그먼트의 순서 번호 필드에 이 번호를 넣음
     + 이 세그먼트는 IP 데이터그램 안 캡슐화되고 서버로 송신
     + 특정 보안 공격을 피하고자 client_isn의 선택을 적절히 임의 추출함

   - 2단계 : TCP SYN 세그먼트를 포함하는 IP 데이터그램이 서버 호스트에 도착하면, 서버는 데이터그램으로부터 TCP SYN 세그먼트 추출
     + 연결에 TCP 버퍼와 변수를 할당
     + 클라이언트 TCP로 연결 승인 세그먼트를 송신 (단, 3-Way Handshake를 완료하기 전에 변수와 버퍼를 할당할 경우 SYN 플러딩 서비스 거부 공격에 취약해짐)
     + 연결 승인 세그먼트도 애플리케이션 계층 데이터를 포함하지 않음
     + 그러나 세그먼트 헤더 안 3개의 중요 정보 포함
       * SYN 비트는 1로 설정
       * TCP 세그먼트 헤더의 확인 응답 필드는 client_isn + 1로 설정
       * 서버는 자신의 최초 순서 번호(server_isn)를 선택하고, TCP 세그먼트 헤더의 순서 번호 필드에 이 값을 넣음
       * 즉, 최초 순서 번호 client_isn을 가지고 연결을 시작하는 SYN 패킷에 대해 연결 설정에 동의하며, 최초 순서 번호는 server_isn임을 말하는 것
       * 연결 승인 세그먼트는 SYNACK 세그먼트로 불림

   - 3단계 : 연결 승인 세그먼트를 수신하면, 클라이언트는 연결에 버퍼와 변수를 할당
     + 클라이언트 호스트는 서버로 또 다른 세그먼트를 송신
     + 마지막 세그먼트가 서버의 연결 승인 세그먼트를 확인 (클라이언트는 TCP 세그먼트 헤더의 확인 응답 필드 안에 server_isn + 1 값을 넣음)
     + 연결이 설정되었으므로 SYN 비트는 0으로 설정
     + 클라이언트에서 서버로의 데이터를 세그먼트 페이로드에서 운반 가능

4. 세 단계가 완료되면, 클라이언트와 서버 호스트들은 각 서로에게 데이터를 포함하는 세그먼트 전송 가능하며, 이 다음의 세그먼트에서는 SYN 비트는 0으로 설정
5. 연결 설정을 위해 두 호스트 사이 3개의 패킷이 송신되므로 TCP 연결 설정 절차를 3-Way Handshake라고 부름

6. TCP 연결 종료
<div align="center">
<img src="https://github.com/user-attachments/assets/0a284154-0a44-4953-a81d-808e9e727db5">
</div>

  - TCP 연결에 참여하는 두 프로세스 중 하나가 연결을 끝낼 수 있으며, 연결이 끝날 때, 호스트의 자원(버퍼와 변수)는 회수
  - 클라이언트 애플리케이션 프로세스는 종료 명령을 내리고, 이는 클라이언트 TCP가 서버 프로세스에게 특별한 TCP 세그먼트를 보내도록 함
  - FIN 비트라 불리는 플래그 비트를 1로 설정한 뒤, 세그먼트 헤더에 포함
  - 서버가 이 세그먼트를 수신하면, 서버는 클라이언트에게 확인 응답 세그먼트를 보내고, FIN 비트가 1로 설정되 자신의 종료 세그먼트를 송신
  - 마지막으로 클라이언트는 서버의 종료 세그먼트에 대한 확인 응답 실시하면서, 이 시점에서 두 호스트의 모든 자원 할당 해제

-----
### TCP 상태 전이
-----
1. TCP 연결이 존재하는 동안 각 호스트에서 동작하는 TCP 프로토콜은 다양한 TCP 상태로 두루 전이
2. 클라이언트 TCP에서 TCP 상태 변이 일반적인 순서
<div align="center">
<img src="https://github.com/user-attachments/assets/92c89f78-f8ae-4543-982f-ca6028708e07">
</div>

  - 클라이언트 TCP는 CLOSED 상태에서 시작
  - 클라이언트 측의 애플리케이션은 새로운 TCP 연결(소캣 객체 생성) 시작 : 클라이언트의 TCP가 서버의 TCP에게 SYN 세그먼트를 송신하도록 하는 것
  - SYN 세그먼트를 송신한 뒤, 클라이언트 TCP는 SYN_SENT 상태로 들어감 : 클라이언트 TCP는 서버 TCP로부터 1로 설정된 SYN 비트와 이전 세그먼트에 대한 확인 응답을 가진 세그먼트를 기다림
  - 세그먼트를 수신하면, 클라이언트 TCP는 ESTABLISHED 상태로 들어감 : TCP 클라이언트는 애플리케이션에서 발생된 페이로드 데이터를 포함하는 TCP 세그먼트를 송신하고 수신할 수 있음

  - 클라이언트 애플리케이션이 연결 종료를 희망한다고 가정
    + 클라이언트 TCP가 1로 설정된 FIN 비트를 포함하는 TCP 세그먼트를 송신하도록 함
    + FIN_WAIT_1 상태로 들어감 : 클라이언트 TCP는 서버로부터 확인 응답을 포함하는 TCP 세그먼트를 기다림
    + 이 세그먼트를 수신할 때, 클라이언트 TCP는 FIN_WAIT2 상태로 들어감 : 클라이언트는 서버로부터 1로 설정된 FIN 비트를 포함하는 다른 세그먼트를 기다림
    + 이 세그먼트를 수신하면, 클라이언트 TCP는 서버의 세그먼트에 확인 응답을 전송하고, TIME_WAIT 상태로 들어감 : TCP 클라이언트가 ACK 손실되면 마지막 확인 응답을 재송신하도록 함 (대체로 TIME_WAIT는 30초, 1분 또는 2분)
    + 대기 시간이 끝나면 연결은 정식으로 종료되고, 클라이언트 측의 포트 번호를 포함한 모든 자원 해제

3. 서버 TCP에서 TCP 상태 변이 일반적인 순서
<div align="center">
<img src="https://github.com/user-attachments/assets/29a87cc5-61fa-42d0-a5a1-7b20ef8df17d">
</div>

   - 클라이언트가 SNY 세그먼트를 보내는 것을 서버는 포트로 듣고 있음
     + 호스트가 호스트 내부에서 진행되는 어떤 소켓과 관계없는 포트 번호와 출발지 IP 주소를 가진 TCP 세그먼트를 수신하면, 해당 목적지 포트는 TCP SYN 패킷을 수신
     + 하지만, 호스트는 연결을 수락하지 않고 있으므로, 특별한 리셋 세그먼트를 보낼 것 (TCP 세그먼트는 1로 설정한 RST 플래그 비트를 가지는데, 이는 호스트가 리셋 세그먼트를 전송할 때, 출발지에게 그 세그먼트에 대한 소켓을 가지고 있지 않으니 세그먼트를 재전송하지 말 것이라는 의미)

4. 호스트가 진행되는 UDP 소켓과 관계 없는 목적지 포트 번호를 갖는 UDP 패킷 수신의 경우 : 특별한 ICMP 데이터그램 전송
   - nmap 포트 스캔 도구로 확인 가능한 세 가지 결과
     + 출발지 호스트가 목표 호스트로부터 TCP SYNACK 세그먼트 수신 : nmap은 open 반환
     + 출발지 호스트가 목표 호스트로부터 TCP RST 세그먼트 수신 : 실행되지 않는 것을 의미 (하지만, 최소한 연결된 포트로 호스트를 목적지로 하는 세그먼트가 출발지와 목표 호스트 간의 경로 상 어떤 방화벽에도 차단되지 않음을 의미)
     + 출발지가 아무것도 받지 않음 : SYN 세그먼트가 중간에 방화벽에 의해 차단되어 목표 호스트에 전혀 도달하지 않음
   - nmap은 방화벽과 그 구성, 심지어 애플리케이션과 운영체제의 버전에 대한 열려 있는 TCP 포트 뿐만 아니라 UDP 포트까지 사전 조사 가능 (대부분 TCP 연결 관리 세그먼트를 다룸으로 얻을 수 있음)

-----
### SYN 플러드 공격
-----
1. 서버가 수신된 SYN에 대해 응답으로 연결 변수와 버퍼를 할당하고 초기화함
   - 서버는 응답으로 SYNACK를 보내고 클라이언트 ACK 세그먼트를 기다림
   - 클라이언트가 3-Way Handshake의 세 번째 단계를 완료하기 위해 ACK를 보내지 않으면 결국 서버가 절반만 열린 연결을 종료하고, 할당된 자원 회수

2. TCP 연결 관리 프로토콜은 SYN 플러드 공격(SYN Flood Attack)이라는 DDoS 공격에 취약
   - 공격자는 3-Way Handshake의 세 번째 단계를 완료하지 않은 상태에서 무수한 TCP SYN 세그먼트를 보냄
   - TCP SYN 세그먼트의 대홍수로 서버 연결 자원이 반쪽 연결에 할당되어(전혀 사용되지 않음), 결국 서버 연결 자원이 소진됨에 따라 합법적 클라이언트들이 서비스 거부가 됨

3. 해결책 : SYN 쿠키
   - 서버가 SYN 세그먼트를 받을 때, 그 세그먼트가 정당한 사용자로부터 온 것인지 SYN 플러드 공격의 한 부분인지 알 수 없으므로, 서버는 SYN에 대해 반만 열린 TCP 연결을 만들지 않음
   - 대신 서버는 자신만 오직 아는 비밀번호 뿐 아니라 SYN 세그먼트의 출발지와 목적지 IP 주소들과 포트 번호들의 복잡한 해시 함수로 초기 TCP 순서 번호를 만듬 (쿠키)
   - 서버는 이 특별한 쿠키를 가진 SYNACK 패킷을 보내고, 서버가 SYN에 관련된 쿠키나 어떤 다른 상태 정보를 기억하지 않음

   - 합법적인 클라이언트 ACK 세그먼트를 회신하며, 이 ACK를 받은 서버는 ACK가 이전에 보낸 일부 SYN에 관한 것인지 확인하는데, 쿠키를 통해 확인
     + 확인 응답 필드에 있는 값은 SYNACK에 있는 순서 번호 1을 더한 것
     + 서버는 SYNACK 세그먼트에 있는 출발지와 목적지 IP 주소와 포트 번호 그리고 비밀번호를 사용해 동일한 해시 함수를 실행하는데, 함수의 결과에 1을 더한 것이 클라이언트의 SYNACK에 있는 확인 응답 번호(쿠키)와 같다면, 서버는 ACK가 초기 SYN 세그먼트에 관련된 것이고, 올바른 것
     + 이후 서버는 소켓을 가지고 완전히 열린 연결을 만듬

   - 반면 클라이언트가 ACK 세그먼트를 회신하지 않으면, 서버가 처음의 가짜 SYN에 대해 어떤 자원도 할당하지 않았으므로 처음 SYN은 서버에 해를 끼치지 못함
