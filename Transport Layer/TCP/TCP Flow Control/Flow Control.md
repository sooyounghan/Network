-----
### 흐름 제어
-----
1. TCP 연결이 순서대로 올바르게 바이트를 수신할 때는 TCP는 데이터를 수신 버퍼에 저장
   - 해당 애플리케이션 프로세스는 버퍼에서 데이터를 읽지만, 데이터가 도달한 시점에서는 읽을 필요가 없음
   - 애플리케이션이 데이터를 읽는 속도가 비교적 느리다면, 송신자가 점점 더 많은 데이터를 빠르게 전송함으로 연결 수신 버퍼에 아주 쉽게 오버플로우 발생

2. TCP는 송신자가 수신자의 버퍼를 오버플로우 시키는 것을 방지하기 위해 애플리케이션에게 흐름 제어 서비스(Flow-Control Service) 제공
   - 속도를 일치시키는 서비스로, 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 하는 것
   - TCP 송신자는 IP 네트워크에서 혼잡 때문에 억제될 수 있는데, 송신자 제어의 형태는 혼잡 제어(Congestion Control)

3. 가정 : TCP 수신자가 순서가 바뀐 세그먼트를 버린다고 가정
4. TCP는 송신자가 수신 윈도(Receive Window)라는 변수를 유지하여 흐름 제어를 제공
   - 수신 윈도를 수신 측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려주는데 사용
   - TCP는 전이중(Full-Duplex)이므로 연결의 각 측 송신자는 별개의 수신 윈도를 유지
   - TCP 연결 상 호스트 A가 호스트 B에게 큰 파일을 전송한다고 가정할 때, 호스트 B는 이 연결에 수신 버퍼를 할당하며, 이 때 할당된 수신 버퍼 크기를 RcvBuffer
   - 호스트 B의 애플리케이션 프로세스는 버퍼로부터 데이터를 읽으며 다음 변수 정의
     + LastByteRead : 호스트 B의 애플리케이션 프로세스에 의해 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트 번호
     + LastByteRcvd : 호스트 B의 네트워크로부터 도착하여 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 번호

   - TCP는 할당된 버퍼의 오버플로우를 허용하지 않으므로 다음 수식이 가능
```
LastByteRcvd - LastByteRead ≤ RcvBuffer
```
   - rwnd로 명명된 수신 버퍼는 버퍼 여유 공간을 설정
```
rwnd = RcvBuffer - [ LastByteRcvd - LastByteRead ]
```
   - 시간에 따라 여유 공간은 변하므로 rwnd는 동적
<div align="center">
<img src="https://github.com/user-attachments/assets/b76cadfd-df69-4a55-baed-4c97302253d8">
</div>

   - 호스트 B는 호스트 B가 호스트 A에게 전송하는 모든 세그먼트의 윈도 필드에 현재 rwnd 값을 설정함으로써 연결 버퍼에 얼마만큼의 여유 공간이 있는지 호스트 A에게 알려줌
     + 초기 : 호스트 B가 rwnd = RcvBuffer로 설정
   - 반면, 호스트 A는 명백한 의미가 있는 두 변수 LastByteSend와 LastByteAcked를 유지
   - 이 두 변수의 차이 (LastByteSend - LastByteAcked)는 호스트 A가 이 연결에 전송 확인 응답이 안 된 데이터의 양으로, rwnd 보다 값으로 확인 응답 안 된 데이터의 양을 유지함으로 호스트 A는 호스트 B의 수신 버퍼에 오버플로우가 발생하지 않는다는 것을 확신
```
LastByteSend - LastByteAcked ≤ rwnd
```

  - 호스트 B의 수신 버퍼는 rwnd = 0으로 가득찼다고 가정
     + 호스트 A에게 rwnd = 0이라고 알린 후, 호스트 B는 호스트 A에게 전송할 게 없다고 가정
     + 호스트 B에서 애플리케이션 프로세스가 버퍼를 비우더라도, TCP는 호스트 A에게 새로운 rwnd로 새로운 세그먼트를 전송하지 않음
     + 즉, TCP는 전송할 데이터가 있거나 전송해야 할 확인 응답을 가진 경우에만 호스트 A에게 세그먼트를 전송할 것이므로, 호스트 A는 호스트 B의 수신 버퍼에 약간의 공간이 있다는 것을 모르므로, 호스트 A는 차단되고 더는 데이터 전송 불가

    - 💡 따라서, TCP 명세서는 호스트 A가 호스트 B의 수신 윈도가 0일 때, 1바이트 데이터로 세그먼트를 계속해서 전송하도록 요구 : 이 세그먼트들은 수신자에 의해 긍정 확인 응답이 될 것
      + 결과적으로 버퍼는 비워지고 긍정 확인 응답은 0이 아닌 rwnd이 될 것

 5. UDP의 흐름 제어
    - 호스트 A가 한 프로세스로부터 호스트 B의 프로세스에게 연속적인 UDP 세그먼트를 전송하는 경우
    - 전형적 UDP 구현 경우, UDP는 대응하는 소켓 앞에 위치한 유한 크기 버퍼에 세그먼트들을 쌓을 것이며, 프로세스는 버퍼로부터 한 번에 하나의 전체 세그먼트를 읽음
    - 프로세스가 버퍼로부터 매우 빠르게 세그먼트를 읽지 못하면, 버퍼는 오버플로우가 될 것이며, 세그먼트를 잃어버림
