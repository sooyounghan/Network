-----
### TCP 세그먼트 구조
-----
1. 헤더 필드와 데이터 필드로 구성
   - 데이터 필드는 애플리케이션 데이터의 일정량을 담으며, MSS는 세그먼트의 데이터 필드의 크기를 제한
     + TCP가 웹 문서의 이미지와 같은 큰 파일을 전송할 때, 일반적으로 MSS 크기의 파일을 분절 (통상 MSS 보다 작은 마지막 분절은 제외)
     + 그러나 많은 대화식 애플리케이션에서는 MSS보다 작은 양의 데이터 전송 (텔넷, SSH와 같은 원격 로그인에서는 TCP 세그먼트 안 데이터 필드는 오직 1바이트를 가지며, TCP 헤더는 일반적으로 20바이트(UDP 헤더보다 12바이트 큼)이므로, 전송되는 세그먼트는 단지 21바이트 길이)

2. TCP 세그먼트 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/069238aa-b899-43ea-9a52-0ad7372bc9b4">
</div>

  - 출발지와 목적지 포트 번호 (Source and Destination Port Number) : 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는데 사용
  - 체크섬 필드 (Checksum Field)
  - 32비트 순서 번호 필드(Sequence Number Field)와 32비트 확인 응답 번호 필드(Acknowledgement Number Field) : 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해 사용
  - 16비트 수신 윈도(Receive Window) 필드 : 흐름 제어에 사용되며, 수신자가 받아들이려는 바이트의 크기를 나타내는데 사용
  - 4비트 헤더 길이 필드(Header Length Field) : 32비트 워드 단위로 TCP 헤더 길이를 나타내며, TCP 헤더는 TCP 옵션(Option) 필드 때문에 가변적인 길이가 될 수 있음 (일반적으로, 옵션 필드는 일반적인 TCP 길이가 20바이트가 되도록 비어 있음)
  - 옵션 필드 (Option Field) : 선택적이고 가변적인 길이로서, 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용되며, 타임스탬프 옵션 또한 정의
  - 6비트 플래그 필드(Flag Field)
    + ACK 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는데 사용 (즉, 이 세그먼트는 성공적으로 수신된 세그먼트에 대한 확인 응답을 포함)
    + RST, SYN, FIN 비트 : 연결 설정과 해제에 사용
    + PSH 비트 : 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킴
    + URG 비트 : 세그먼트에서 송신 측 상위 개체가 긴급으로 표시하는 데이터임을 가리킴 (긴급 데이터의 마지막 바이트의 위치는 1비트의 긴급 데이터 포인터 필드(Urgent Data Pointer Field)에 의해 가리켜짐)
      * TCP는 긴급 데이터가 존재할 때, 수신 측 상위 계층 개체에게 통지해야 하고, 긴급 데이터 끝에 대한 포인터를 전달

3. 순서 번호와 확인 응답 번호
   - TCP 세그먼트 헤더에서 가장 중요한 필드 두 가지 : 순서 번호 필드와 확인 응답 필드 (TCP 신뢰적 데이터 전송 서비스의 중요 부분)
   - 💡 TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 봄
     + TCP의 순서 번호, 사용은 순서 번호가 일련의 전송된 세그먼트에 대해서가 아닌, 전송된 바이트 스트림에 대한 관점을 반영
     + 세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호

   - 예제
<div align="center">
<img src="https://github.com/user-attachments/assets/2f3d661e-36a2-401d-ab13-6fbb277c8d43">
</div>

  - 호스트 A에서의 프로세스는 TCP 연결 상에서 호스트 B의 프로세스로 데이터 스트림을 전송하기 원한다고 가정
  - 호스트 A의 TCP는 데이터 스트림의 각 바이트에 암시적으로 순서 번호를 지정
  - 데이터 스트림은 500,000바이트로 구성된 파일이락 가정
  - MSS는 1,000 바이트이며, 데이터 스트림의 첫 번째 바이트는 0으로 설정했다고 가정하고, TCP 데이터 스트림으로부터 500개의 세그먼트들을 구성
    + 첫 번째 세그먼트는 순서 번호 0, 두 번째 세그먼트 순서 번호 1000, 세 번쨰 세그먼트 순서 번호 2000과 같은 식으로 할당
    + 각 순서 번호는 적절한 TCP 세그먼트 헤더 내부 순서 번호 필드에 삽입
  - 확인 응답 번호에 대해 TCP는 호스트 A가 호스트 B로 데이터를 송신하는 동안 호스트 B로부터 데이터를 수신하게 해주는 전이중 방식임
    + 호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어온 데이터에 대한 순서 번호를 가짐
    + 💡 호스트 A가 자신의 세그먼트에 삽입하는 확인 응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호
  - 호스트 A가 B로부터 0에서 535까지 번호가 붙은 모든 바이트를 수신했다고 가정
    + 호스트 B로 세그먼트를 송신하려 한다고 가정
    + 호스트 A는 호스트 B의 데이터 스트림에서 536번째 바이트와 그 다음에 오는 바이트를 기다리고 있으므로, 호스트 A는 세그먼트의 확인응답 번호 필드에 536을 삽입하고 이를 B에 송신
  - 호스트 A가 호스트 B로부터 0 ~ 535의 바이트를 포함하는 어떤 세그먼트와 900 ~ 1000 바이트를 포함하는 또 다른 세그먼트를 수신했다고 가정
    + 호스트 A는 536 ~ 899의 바이트를 아직 수신하지 않았으며, 호스트 A는 B의 데이터 스트림을 재생성하기 위해 536번째와 그 다음의 바이트를 아직 기다림
    + 그러므로, B에 대한 A의 다음 세그먼트는 확인 응답 번호 필드에 536을 가질 것임
  - 💡 TCP는 스트림에 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인 응답하므로, 누적 확인 응답 (Cumulative Acknowledgement)를 제공한다고 함
  - 호스트 A가 세 번째 세그먼트(900 ~ 1000 값의 바이트)를 두 번째 세그먼트(536 ~ 899 값의 바이트)가 수신되기 전에 수신
    + 즉, 세 번째 세그먼트는 순서가 틀리게 도착
    + TCP RFC는 이 부분에 대해 어떠한 규칙을 부여하지 않았고, TCP 구현 개발자에게 맡김
    + 기본적으로 2가지 선택 존재
      * 수신자가 순서를 바뀐 세그먼트를 즉시 버림
      * 수신자는 바뀐 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해 대기 (네트워크 대역폭 관점에서 효율적이며, 실제 취하는 방법)
    + 시작 순서 번호가 0이라고 가정했지만, 실제로는 TCP 연결 양쪽 모두 시작 순서 번호를 임의로 선택 : 아직 네트워크에 남아 있던 세그먼트가 같은 두 호스트 간의 나중에 연결(또한 이전의 연결과 같은 포트 번호를 사용해 발생)에서 유효한 세그먼트로 오인될 확률 최소화

4. Telnet
   - RFC 854에서 정의된 텔넷은 원격 로그인을 위해 사용되는 애플리케이션 계층 프로토콜
   - TCP상에서 실행되며, 한 쌍의 호스트들 사이에서 동작하도록 설계
   - 대화형 애플리케이션 (TCP 순서와 확인 응답 번호 설명에 용이)
   - 다만, 패스워드를 포함하는 텔넷 연결에서 전송된 데이터는 암호화되지 않아 도청 공격에 취약하므로, SSH 프로토콜 선호
   - 호스트 A가 호스트 B와 텔넷 세션을 시작한다고 가정
     + 호스트 A는 세션을 시작하므로 클라이언트이며, 호스트 B는 서버
     + 클라이언트에서 사용자가 입력한 문자는 원격 호스트에게 송신
     + 원격 호스트는 각 문자의 복사본을 송신자에게 반송하여 텔넷 사용자의 화면에 표시 (에코 백(Echo Back)은 텔넷 사용자가 보는 문자가 이미 원격 사이트에 수신되고 처리되었음을 나타냄)
     + 각 문자는 사용자가 키를 누르는 시간과 문자가 사용자의 모니터에 표시되는 시간 사이에서 네트워크를 두 번 횡단

<div align="center">
<img src="https://github.com/user-attachments/assets/d44aad35-31b7-4b06-bc7e-81e6327364fd">
</div>

  - 초기 순서 번호가 클라이언트와 서버에 대해 각 42와 79라고 가정
  - 세그먼트 순서 번호는 데이터 필드 안에 있는 첫 번째 바이트 순서 번호임
  - 클라이언트 송신된 첫 번째 세그먼트는 순서 번호 42를 가지며, 서버로부터 송신된 첫 번째 세그먼트는 79를 가짐
  - 확인 응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호
  - 따라서, TCP 연결이 설정된 후 어떤 데이터도 송신되기 전 클라이언트는 바이트 79를 기다리며, 서버는 바이트 42를 기다림
  - 3개의 세그먼트가 송신
    + 첫 번째 세그먼트는 클라이언트에서 서버로 송신 : 데이터 필드 안에 문자 'C'의 1바이트 ASCII 표현을 포함 (순서 번호 필드 안 42를 가지며, 클라이언트가 아직 서버로부터 어떠한 데이터도 수신하지 못했으므로, 첫 번째 세그먼트는 확인 응답 번호 필드에 79를 가짐)
    + 두 번쨰 세그먼트는 서버에서 클라이언트로 송신
      * 수신하는 서버에게 데이터에 대한 확인응답 제공하므로 확인 응답 필드 안에는 43를 넣음으로, 서버는 클라이언트에게 바이트 42를 성공적으로 수신했고, 앞으로 바이트 43을 기다림을 말해줌
      * 문자 'C'를 반대로 반향되도록 하는 것이므로, 이러한 TCP 연결의 서버-클라이언트 데이터 흐름이 최초 순서 번호인 순서 번호인 79를 가짐 (바이트 79는 서버가 보내는 데이터의 맨 첫 번째 바이트)
      * 💡 클라이언트-서버 데이터에 대한 확인응답은 서버와 클라이언트 간에서 데이터를 운반하는 세그먼트 안에서 전달 : 이러한 확인응답은 서버-클라이언트 데이터 세그먼트 상 피기백(Piggyback)된다고 말함
    + 세 번째 세그먼트는 클라이언트에서 서버로 송신 : 서버로부터 수신한 데이터에 대한 확인 응답
      * 이 세그먼트는 빈 데이터 필드를 가지는데, 즉, 확인 응답은 어떤 클라이언트-서버 데이터와 함께 피기백되지 않음
      * 세그먼트는 확인 응답 필드 안에 80을 가짐 (순서 번호 79 바이트를 통해 바이트의 스트림을 클라이언트가 수신했기 때문이므로, 이제는 80으로 시작하는 바이트를 기다림)
      * TCP가 순서 번호 필드를 가지므로 세그먼트 역시 어떤 순서 번호를 가져야 함 (데이터를 포함하지 않더라도 가져야 함)

-----
### 왕복 시간(RTT) 예측과 타임 아웃
-----
1. 타임아웃은 세그먼트가 전송된 시간부터 긍정 확인응답될 때까지 시간인 연결 왕복 시간(Round-Trip Time, RTT)보다 커야 하며, 그렇지 않으면 불필요한 재전송이 발생
2. 왕복 시간 예측
   - SampleRTT로 표시되는 세그먼트에 대한 RTT 샘플 : 세그먼트가 송신된 시간(즉, IP에게 넘겨진 시간)으로부터 그 세그먼트에 대한 긍정 응답이 도착한 시간까지의 시간 길이
   - 모든 전송된 세그먼트에 대해 SampleRTT를 측정하는 대신, 대부분의 TCP는 한 번에 하나의 SampleRTT 측정만을 시행 (즉, 어떤 시점에서 SampleRTT는 전송되었지만, 현재까지 확인 응답이 없는 세그먼트 중 하나에 대해서만 측정되며, 이는 대략 왕복 시간마다 SampleRTT의 새로운 값을 얻게 함)
   - TCP는 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않으며, 한 번 전송된 세그먼트에 대해서만 측정
   - SampleRTT 값은 라우터에서의 혼잡과 종단 시스템에서의 부하 변화 때문에 세그먼트마다 다르며, 불규칙적인 값이므로 대체로 RTT를 추정하기 위해 SampleRTT의 평균값을 채택
   - 따라서, TCP는 SampleRTT 값의 평균(EstimatedRTT)을 유지
     + 긍정 확인 응답을 수신하고 새로운 SampleRTT를 획득하자마자 TCP는 다음 공식에 따라 갱신
<div align="center">
<img src="https://github.com/user-attachments/assets/c4b72427-c343-4fa6-a3d6-b3224c618b6b">
</div>

   - EstimatedRTT의 새로운 값은 이전 값과 새로운 값의 가중된 조합이며, 권장되는 값은 α = 0.125
   - 즉, EstimatedRTT는 SampleRTT 값의 가중 평균(Weighted Average)
     + 가중평균은 예전 샘플보다 최근 샘플에 더 높은 가중치를 줌
     + 최신 샘플들은 네트워크 상에 현재 혼잡을 더 잘 반영함
     + 통계에서는 이런 평균을 지수적 가중 이동 평균(Exponential Weighted Moving Average, EWMA) : 주어진 SampleRTT의 가중치가 갱신 절차에 진행됨에 따라 빠르게 지수적으로 감소하므로 EWMA에서 지수적이라는 용어가 사용

<div align="center">
<img src="https://github.com/user-attachments/assets/19140bcd-fd9f-49c1-98d8-3697e5db686a">
</div>

   - SampleRTT의 변화가 EstimatedRTT 계산에서 완만하게 됨을 보여줌
   - RTT 예측 외에 RTT의 변환율을 측정하는 것도 유용 : RTT 변화율을 의미하는 DevRTT를 SampleRTT가 EstimatedRTT로부터 얼마나 많이 벗어났는지에 대한 예측으로 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/f653451c-bd2d-49c4-98f0-a31f4771bc94">
</div>

   - DevRTT는 SampleRTT와 EstimatedRTT 값 차이의 EWMA
   - 만일 SampleRTT 값이 어떠한 변화도 없다면, DevRTT는 작을 것이며, 그렇지 않다면 클 것이고, β = 0.2가 권장값

3. 재전송 타임아웃 주기의 설정과 관리
   - TCP 타임 아웃 주기는 EstimatedRTT보다 너무 크면 안 되며, 너무 크면 세그먼트를 잃었을 때 TCP는 즉각적인 세그먼트 재전송을 하지 않게 됨
   - 이 때문에, 애플리케이션에서 전송 지연이 발생하므로, EstimatedRTT에 약간의 여윳값을 더한 값으로 설정하는 것이 바람직
   - SampleRTT 값에 많은 변동이 있을 때 여윳값이 커야 하며, 변동이 작을 때는 작아야 함 (즉, DevRTT 값이 그 역할을 함)
   - 이러한 모든 고려사항은 재전송 타임아웃 주기를 결정하는 TCP 방식에 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/48858b36-02b4-4795-9c85-b00ef39a3424">
</div>

   - 초기 TimeoutInterval의 값으로 1초를 권고
   - 타임아웃이 발생하면 TimeoutInterval의 값은 두 배로 하여 조만간 확인 응답할 후속 세그먼트에게 발생할 수 있는 조기 타임아웃을 피하도록 함
   - 그러나 세그먼트가 수신되고, EstimatedRTT가 수정되면 TimeoutInterval은 다시 위 공식에 따라 계산

-----
### 신뢰적인 데이터 전송
-----
1. TCP의 신뢰적인 데이터 전송 서비스는 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으며, 손실이나 중복이 없다는 것과 순서가 유지된다는 것을 보장
   - 즉, 바이트 스트림은 송신자가 전송한 것과 같은 바이트 스트림
2. 아직 확인응답을 받지 못한 각 세그먼트와 개별적인 타이머가 한 쌍이 되어 동작하지만, 이러한 타이머 관리는 상당한 오버헤드를 요구할 수 있음
   - 따라서, 전송되었지만 확인 응답이 안 된 다수의 세그먼트들이 있다고 하더라도, 권장 되는 TCP 타이머 관리 절차에서는 오직 단일 재전송 타이머를 사용
3. TCP의 신뢰적인 데이터 전송 단계 (호스트 A에서 B로 데이터가 오직 한 방향으로만 보내지며, 호스트 A가 큰 파일을 전송)
   - 손실 세그먼트를 복구 하기 위해 타임아웃만을 사용하는 TCP 송신자의 매우 간소화된 설명을 보여주고, 다음으로 타임아웃에 추가하여 중복 확인 응답을 이용
<div align="center">
<img src="https://github.com/user-attachments/assets/fef246f1-9340-41cb-9c2e-20736fcc9a14">
</div>

   - 첫 번째 주요 이벤트 발생 : TCP는 애플리케이션으로부터 데이터를 받고, 세그먼트로 이 데이터를 캡슐화하고, IP에게 이 세그먼트를 넘김
     + 세그먼트의 첫 번째 데이터 바이트의 바이트 열 번호인 순서 번호를 포함
     + 또한, 타이머가 이미 다른 세그먼트에 대해 실행 중이 아니라면, TCP는 이 세그먼트를 IP로 넘길 때 타이머를 시작
     + 이 타이머에 대한 만료 주기는 TimeoutInterval이며, EstimatedRTT와 DevRTT로 계산 가능

   - 두 번째 주요 이벤트 발생 : 타임아웃으로, TCP 타임 아웃 이벤트에 대해 타임아웃을 일으킨 세그먼트를 재전송하여 응답하고, TCP 타이머를 다시 시작

   - 세 번째 주요 이벤트 : 수신자로부터(다양한 ACK 필드 값을 가진 세그먼트인) 수신 확인 응답 세그먼트(ACK) 수신
     + TCP는 변수 SendBase와 ACK 값 y를 비교
     + SendBase : 수신 확인 응답이 확인 되지 않은 가장 오래된 바이트의 순서 번호 (SendBase - 1은 수신자에게서 정확하게 차례대로 수신되었음을 알리는 마지막 바이트의 순서 번호)
     + TCP는 누적 확인 응답을 사용하고, y는 y바이트 이전 모든 바이트의 수신을 확인
     + y > SendBase이면, ACK는 이전 확인 응답이 안 된 하나 이상의 세그먼트들을 확인하고, 송신자는 자신의 SendBase 변수 갱신
     + 또한, 아직 확인 응답이 안 된 세그먼트들이 존재한다면 타이머를 다시 시작

-----
### 예제
-----
1. 호스트 A가 호스트 B에게 하나의 세그먼트를 보내는 시나리오
<div align="center">
<img src="https://github.com/user-attachments/assets/d0b30fc3-42ac-4866-b27a-7b22dea4a507">
</div>

   - 세그먼트가 순서 번호 92와 8 바이트의 데이터를 포함한다고 가정
   - 호스트 A가 이 세그먼트를 전송한 후 호스트 A는 호스트 B로부터 긍정 확인 응답 번호 100을 가진 세그먼트를 기다림
   - A로부터 세그먼트 B 측에서 수신되었음에도 B로부터 A로의 긍정 확인 응답이 손실되면, 타임아웃이 일어나고 호스트 A는 같은 세그먼트를 B에게 재전송
   - 물론, 호스트 B가 재전송 세그먼트를 수신했을 때 호스트 B는 세그먼트가 포함하고 있는 순서 번호로부터 이미 수신된 데이터임을 알 수 있으므로, 호스트 B의 TCP는 재송신된 세그먼트의 바이트를 버릴 것

2. 호스트 A가 연속해서 두 세그먼트를 전송하는 시나리오
<div align="center">
<img src="https://github.com/user-attachments/assets/30f9cd98-7213-48a4-8d61-6603077e7bd8">
</div>

   - 첫 번째 세그먼트는 순서 번호 92와 8바이트 데이터를 가지고 있음
   - 두 번째 세그먼트는 순서 번호 100과 20바이트의 데이터를 갖고 있음
   - 두 세그먼트 모두 호스트 B에 의해 무사히 도착한다고 가정
   - B는 각 세그먼트에 대해 2개의 개별적 긍정 확인 응답을 전달
     + 첫 번째는 긍정 확인 응답 번호 100을 가짐
     + 반면, 두 번 째 확인 응답은 응답 번호 120을 가짐
   - 호스트 A에서 타임아웃 이전에 어떠한 긍정 확인 응답도 받지 수신하지 못한다고 가정
     + 타임 아웃 이벤트가 발생하면 호스트 A는 순서 번호 92로 첫 번째 세그먼트를 재전송하고 타이머를 다시 시작
     + 새로운 타임아웃 이전에 두 번째 세그먼트에 대한 ACK가 도착하는 한, 두 번째 세그먼트는 재전송을 하지 않음

3. 호스트 A가 똑같이 2개의 세그먼트를 전송한다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/0147aef3-78da-4200-8a26-dd58432f984a">
</div>

   - 첫 번째 세그먼트의 긍정 확인 응답이 네트워크에서 분실
   - 첫 번째 세그먼트 타임 아웃 전에 호스트 A가 긍정 확인 응답 번호 120의 긍정 확인 응답을 수신하면, 호스트 A는 호스트 B가 119바이트까지 모든 데이터 수신함을 알게 됨
   - 따라서, 호스트 A는 두 세그먼트 중 어느 것도 재전송하지 않음

4. 타임 아웃 주기 두 배 설정
   - 타임 아웃이 발생할 때마다 TCP는 확인 응답이 안 된 가장 작은 순서 번호를 가진 세그먼트를 재전송
   - 타임 아웃 주기를 이전 값의 두 배로 설정 (예) 타이머가 먼저 만료되면, 가장 이전 확인 응답이 되지 않은 세그먼트와 연관된 TimeoutInterval이 0.75초라면, TCP는 이 세그먼트를 재전송하고, 새로운 종료 소요 시간을 1.5초로 설정하고, 또 만료되면, 3.0초로 증가)
   - 이 주기는 각 재전송 후에 지수적으로 증가
     + 하지만, 상위 애플리케이션으로부터 데이터 수신과 ACK 수신은 이후 타이머가 시작될 때 TimeoutInterval이 EstimatedRTT와 DevRTT의 가장 최근의 값에서 가져옴
   - 또한, 이 수정은 제한된 형태의 혼잡을 가져옴
     + 타이머 종료는 주로 네트워크 혼잡에 의해 발생하는데, 즉, 출발지와 목적지 사이 경로에서 하나 이상의 라우터 버퍼에 도착한 많은 패킷의 손실이나 오랜 큐 대기의 원인이 됨
     + 혼잡할 때 출발지에서 지속해서 패킷의 재전송을 고집하면 혼잡은 악화되므로, TCP는 송신자가 더 긴 간격으로 재전송하도록 함

5. 빠른 재전송
   - 타임아웃이 유발하는 재전송의 문제점 : 타임아웃 주기가 때때로 비교적 길어 세그먼트를 잃어버렸을 때, 긴 타임아웃 주기는 잃어버린 패킷을 다시 보내기 전에 송신자를 오랫동안 기다리게 해서 종단 간 지연 증가시킴
   - 하지만, 송신자는 종종 소위 중복 ACK에 의한 타임 아웃이 일어나기 전 패킷 손실을 발견하는데, 중복 ACK(Duplicated ACK)는 송신자가 이미 이전에 받은 확인 응답에 대한 재확인응답 세그먼트 ACK
   - TCP 수신자의 ACK 생성 정책
<div align="center">
<img src="https://github.com/user-attachments/assets/8358aa3c-38dc-4037-bce7-1ca0f60c9243">
</div>

   - 수신자가 중복된 ACK를 보내는 이유
     + TCP 수신자가 기다리는 다음 것 보다 더 큰 순서 번호를 가진 세그먼트를 받았을 때, TCP 수신자는 그 데이터 스트림의 간격(즉, 손실 세그먼트)을 찾아낼 것
     + 이 간격은 네트워크 안에서 세그먼트를 잃어버리거나 순서가 바뀐 결과일 수 있음
     + TCP는 부정 확인 응답을 사용하지 않으므로, 수신자는 송신자에게 부정 확인 응답을 보낼 수 없으므로, 수신자는 마지막으로 수신된 순차적인 바이트를 갖는 데이터를 다시 확인 응답(즉, 중복 ACK 응답을 생성)
   - 송신자는 종종 많은 양의 세그먼트를 연속적으로 보낼 수 있으므로, 만약 하나의 세그먼트를 잃어버린다면 많은 연속적인 중복 ACK가 존재 가능
     + 만약 TCP 송신자가 같은 데이터에 대해 3개의 중복 확인 응답을 수신한다면, 이는 ACK된 세그먼트의 다음 3개의 세그먼트가 분실되었음을 의미
     + 3개의 중복 ACK를 수신할 때, TCP는 세그먼트의 타이머가 만료되기 이전 손실 세그먼트를 재전송하는 빠른 재전송(Fast Retransmit)을 함
     + 두 번째 세그먼트를 잃어버린 경우, 타이머가 만료되기 전 재전송
<div align="center">
<img src="https://github.com/user-attachments/assets/050e5108-aa05-4a6d-afc9-c75840b17523">
</div>

6. TCP의 오류 복구 메커니즘
   - TCP 확인 응답은 누적되고 올바르게 수신되지만, 순서가 잘못된 세그먼트는 수신자가 개별적으로 ACK를 받지 않음
   - TCP 송신자는 전송했지만, 확인 응답이 안 된 바이트의 가장 작은 순서 번호(SendBase)와 전송될 다음 바이트의 순서 번호(NextSeqnum)을 유지해야 함
   - 이러한 관점에서 TCP는 GBN 형태 프로토콜과 유사하지만 차이점 존재
     + 많은 TCP 구현에서는 올바르게 수신되었지만, 순서가 바뀐 세그먼트들을 버퍼링 함
     + 송신자가 세그먼트 1, 2, 3, ..., N을 전송하고 수신 측에 오류 없이 순서대로 도달한다고 가정하고, 패킷 n < N에 대해 긍정 확인 응답이 손실되었지만, 나머지 N - 1개의 긍정 확인 응답들은 타임 아웃 전 송신 측 도달했다고 가정
     + GBN : 패킷 n 뿐만 아니라, 연속적인 패킷 n + 1, n + 2, ..., N 모두 재전송
     + TCP : 세그먼트 n 하나만을 재전송하며, 세그먼트 n에 대해 타임아웃 전 세그먼트 n + 1에 대한 긍정 확인 응답이 도착한다면 세그먼트를 재전송하지 않음

  - 따라서, TCP에 수정 제안된 선택적 확인 응답이라고 함
    + TCP 수신자가 마지막으로 올바로 수신된 순서가 맞는 세그먼트에 대해 누적 확인 응답을 하는 것이 아닌, 순서가 틀린 세그먼트에 대해 선택적으로 확인 응답
    + 선택적 재전송과 결합했을 경우(이미 수신자가 선택적 확인 응답을 한 세그먼트 재전송 제외) SR 프로토콜과 매우 유사
    + 따라서, TCP 오류 복구 메커니즘은 GBN과 SR 프로토콜의 혼합으로 분류하는 것이 적당
