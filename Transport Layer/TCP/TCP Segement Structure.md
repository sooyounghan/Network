-----
### TCP 세그먼트 구조
-----
1. 헤더 필드와 데이터 필드로 구성
   - 데이터 필드는 애플리케이션 데이터의 일정량을 담으며, MSS는 세그먼트의 데이터 필드의 크기를 제한
     + TCP가 웹 문서의 이미지와 같은 큰 파일을 전송할 때, 일반적으로 MSS 크기의 파일을 분절 (통상 MSS 보다 작은 마지막 분절은 제외)
     + 그러나 많은 대화식 애플리케이션에서는 MSS보다 작은 양의 데이터 전송 (텔넷, SSH와 같은 원격 로그인에서는 TCP 세그먼트 안 데이터 필드는 오직 1바이트를 가지며, TCP 헤더는 일반적으로 20바이트(UDP 헤더보다 12바이트 큼)이므로, 전송되는 세그먼트는 단지 21바이트 길이)

2. TCP 세그먼트 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/069238aa-b899-43ea-9a52-0ad7372bc9b4">
</div>

  - 출발지와 목적지 포트 번호 (Source and Destination Port Number) : 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는데 사용
  - 체크섬 필드 (Checksum Field)
  - 32비트 순서 번호 필드(Sequence Number Field)와 32비트 확인 응답 번호 필드(Acknowledgement Number Field) : 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해 사용
  - 16비트 수신 윈도(Receive Window) 필드 : 흐름 제어에 사용되며, 수신자가 받아들이려는 바이트의 크기를 나타내는데 사용
  - 4비트 헤더 길이 필드(Header Length Field) : 32비트 워드 단위로 TCP 헤더 길이를 나타내며, TCP 헤더는 TCP 옵션(Option) 필드 때문에 가변적인 길이가 될 수 있음 (일반적으로, 옵션 필드는 일반적인 TCP 길이가 20바이트가 되도록 비어 있음)
  - 옵션 필드 (Option Field) : 선택적이고 가변적인 길이로서, 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용되며, 타임스탬프 옵션 또한 정의
  - 6비트 플래그 필드(Flag Field)
    + ACK 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는데 사용 (즉, 이 세그먼트는 성공적으로 수신된 세그먼트에 대한 확인 응답을 포함)
    + RST, SYN, FIN 비트 : 연결 설정과 해제에 사용
    + PSH 비트 : 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킴
    + URG 비트 : 세그먼트에서 송신 측 상위 개체가 긴급으로 표시하는 데이터임을 가리킴 (긴급 데이터의 마지막 바이트의 위치는 1비트의 긴급 데이터 포인터 필드(Urgent Data Pointer Field)에 의해 가리켜짐)
      * TCP는 긴급 데이터가 존재할 때, 수신 측 상위 계층 개체에게 통지해야 하고, 긴급 데이터 끝에 대한 포인터를 전달

3. 순서 번호와 확인 응답 번호
   - TCP 세그먼트 헤더에서 가장 중요한 필드 두 가지 : 순서 번호 필드와 확인 응답 필드 (TCP 신뢰적 데이터 전송 서비스의 중요 부분)
   - 💡 TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 봄
     + TCP의 순서 번호, 사용은 순서 번호가 일련의 전송된 세그먼트에 대해서가 아닌, 전송된 바이트 스트림에 대한 관점을 반영
     + 세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호

   - 예제
<div align="center">
<img src="https://github.com/user-attachments/assets/2f3d661e-36a2-401d-ab13-6fbb277c8d43">
</div>

  - 호스트 A에서의 프로세스는 TCP 연결 상에서 호스트 B의 프로세스로 데이터 스트림을 전송하기 원한다고 가정
  - 호스트 A의 TCP는 데이터 스트림의 각 바이트에 암시적으로 순서 번호를 지정
  - 데이터 스트림은 500,000바이트로 구성된 파일이락 가정
  - MSS는 1,000 바이트이며, 데이터 스트림의 첫 번째 바이트는 0으로 설정했다고 가정하고, TCP 데이터 스트림으로부터 500개의 세그먼트들을 구성
    + 첫 번째 세그먼트는 순서 번호 0, 두 번째 세그먼트 순서 번호 1000, 세 번쨰 세그먼트 순서 번호 2000과 같은 식으로 할당
    + 각 순서 번호는 적절한 TCP 세그먼트 헤더 내부 순서 번호 필드에 삽입
  - 확인 응답 번호에 대해 TCP는 호스트 A가 호스트 B로 데이터를 송신하는 동안 호스트 B로부터 데이터를 수신하게 해주는 전이중 방식임
    + 호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어온 데이터에 대한 순서 번호를 가짐
    + 💡 호스트 A가 자신의 세그먼트에 삽입하는 확인 응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호
  - 호스트 A가 B로부터 0에서 535까지 번호가 붙은 모든 바이트를 수신했다고 가정
    + 호스트 B로 세그먼트를 송신하려 한다고 가정
    + 호스트 A는 호스트 B의 데이터 스트림에서 536번째 바이트와 그 다음에 오는 바이트를 기다리고 있으므로, 호스트 A는 세그먼트의 확인응답 번호 필드에 536을 삽입하고 이를 B에 송신
  - 호스트 A가 호스트 B로부터 0 ~ 535의 바이트를 포함하는 어떤 세그먼트와 900 ~ 1000 바이트를 포함하는 또 다른 세그먼트를 수신했다고 가정
    + 호스트 A는 536 ~ 899의 바이트를 아직 수신하지 않았으며, 호스트 A는 B의 데이터 스트림을 재생성하기 위해 536번째와 그 다음의 바이트를 아직 기다림
    + 그러므로, B에 대한 A의 다음 세그먼트는 확인 응답 번호 필드에 536을 가질 것임
  - 💡 TCP는 스트림에 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인 응답하므로, 누적 확인 응답 (Cumulative Acknowledgement)를 제공한다고 함
  - 호스트 A가 세 번째 세그먼트(900 ~ 1000 값의 바이트)를 두 번째 세그먼트(536 ~ 899 값의 바이트)가 수신되기 전에 수신
    + 즉, 세 번째 세그먼트는 순서가 틀리게 도착
    + TCP RFC는 이 부분에 대해 어떠한 규칙을 부여하지 않았고, TCP 구현 개발자에게 맡김
    + 기본적으로 2가지 선택 존재
      * 수신자가 순서를 바뀐 세그먼트를 즉시 버림
      * 수신자는 바뀐 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해 대기 (네트워크 대역폭 관점에서 효율적이며, 실제 취하는 방법)
    + 시작 순서 번호가 0이라고 가정했지만, 실제로는 TCP 연결 양쪽 모두 시작 순서 번호를 임의로 선택 : 아직 네트워크에 남아 있던 세그먼트가 같은 두 호스트 간의 나중에 연결(또한 이전의 연결과 같은 포트 번호를 사용해 발생)에서 유효한 세그먼트로 오인될 확률 최소화

4. Telnet
   - RFC 854에서 정의된 텔넷은 원격 로그인을 위해 사용되는 애플리케이션 계층 프로토콜
   - TCP상에서 실행되며, 한 쌍의 호스트들 사이에서 동작하도록 설계
   - 대화형 애플리케이션 (TCP 순서와 확인 응답 번호 설명에 용이)
   - 다만, 패스워드를 포함하는 텔넷 연결에서 전송된 데이터는 암호화되지 않아 도청 공격에 취약하므로, SSH 프로토콜 선호
   - 호스트 A가 호스트 B와 텔넷 세션을 시작한다고 가정
     + 호스트 A는 세션을 시작하므로 클라이언트이며, 호스트 B는 서버
     + 클라이언트에서 사용자가 입력한 문자는 원격 호스트에게 송신
     + 원격 호스트는 각 문자의 복사본을 송신자에게 반송하여 텔넷 사용자의 화면에 표시 (에코 백(Echo Back)은 텔넷 사용자가 보는 문자가 이미 원격 사이트에 수신되고 처리되었음을 나타냄)
     + 각 문자는 사용자가 키를 누르는 시간과 문자가 사용자의 모니터에 표시되는 시간 사이에서 네트워크를 두 번 횡단

<div align="center">
<img src="https://github.com/user-attachments/assets/d44aad35-31b7-4b06-bc7e-81e6327364fd">
</div>

  - 초기 순서 번호가 클라이언트와 서버에 대해 각 42와 79라고 가정
  - 세그먼트 순서 번호는 데이터 필드 안에 있는 첫 번째 바이트 순서 번호임
  - 클라이언트 송신된 첫 번째 세그먼트는 순서 번호 42를 가지며, 서버로부터 송신된 첫 번째 세그먼트는 79를 가짐
  - 확인 응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호
  - 따라서, TCP 연결이 설정된 후 어떤 데이터도 송신되기 전 클라이언트는 바이트 79를 기다리며, 서버는 바이트 42를 기다림
  - 3개의 세그먼트가 송신
    + 첫 번째 세그먼트는 클라이언트에서 서버로 송신 : 데이터 필드 안에 문자 'C'의 1바이트 ASCII 표현을 포함 (순서 번호 필드 안 42를 가지며, 클라이언트가 아직 서버로부터 어떠한 데이터도 수신하지 못했으므로, 첫 번째 세그먼트는 확인 응답 번호 필드에 79를 가짐)
    + 두 번쨰 세그먼트는 서버에서 클라이언트로 송신
      * 수신하는 서버에게 데이터에 대한 확인응답 제공하므로 확인 응답 필드 안에는 43를 넣음으로, 서버는 클라이언트에게 바이트 42를 성공적으로 수신했고, 앞으로 바이트 43을 기다림을 말해줌
      * 문자 'C'를 반대로 반향되도록 하는 것이므로, 이러한 TCP 연결의 서버-클라이언트 데이터 흐름이 최초 순서 번호인 순서 번호인 79를 가짐 (바이트 79는 서버가 보내는 데이터의 맨 첫 번째 바이트)
      * 💡 클라이언트-서버 데이터에 대한 확인응답은 서버와 클라이언트 간에서 데이터를 운반하는 세그먼트 안에서 전달 : 이러한 확인응답은 서버-클라이언트 데이터 세그먼트 상 피기백(Piggyback)된다고 말함
    + 세 번째 세그먼트는 클라이언트에서 서버로 송신 : 서버로부터 수신한 데이터에 대한 확인 응답
      * 이 세그먼트는 빈 데이터 필드를 가지는데, 즉, 확인 응답은 어떤 클라이언트-서버 데이터와 함께 피기백되지 않음
      * 세그먼트는 확인 응답 필드 안에 80을 가짐 (순서 번호 79 바이트를 통해 바이트의 스트림을 클라이언트가 수신했기 때문이므로, 이제는 80으로 시작하는 바이트를 기다림)
      * TCP가 순서 번호 필드를 가지므로 세그먼트 역시 어떤 순서 번호를 가져야 함 (데이터를 포함하지 않더라도 가져야 함)
