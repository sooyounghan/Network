-----
### TCP 세그먼트 구조
-----
1. 헤더 필드와 데이터 필드로 구성
   - 데이터 필드는 애플리케이션 데이터의 일정량을 담으며, MSS는 세그먼트의 데이터 필드의 크기를 제한
     + TCP가 웹 문서의 이미지와 같은 큰 파일을 전송할 때, 일반적으로 MSS 크기의 파일을 분절 (통상 MSS 보다 작은 마지막 분절은 제외)
     + 그러나 많은 대화식 애플리케이션에서는 MSS보다 작은 양의 데이터 전송 (텔넷, SSH와 같은 원격 로그인에서는 TCP 세그먼트 안 데이터 필드는 오직 1바이트를 가지며, TCP 헤더는 일반적으로 20바이트(UDP 헤더보다 12바이트 큼)이므로, 전송되는 세그먼트는 단지 21바이트 길이)

2. TCP 세그먼트 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/069238aa-b899-43ea-9a52-0ad7372bc9b4">
</div>

  - 출발지와 목적지 포트 번호 (Source and Destination Port Number) : 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는데 사용
  - 체크섬 필드 (Checksum Field)
  - 32비트 순서 번호 필드(Sequence Number Field)와 32비트 확인 응답 번호 필드(Acknowledgement Number Field) : 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해 사용
  - 16비트 수신 윈도(Receive Window) 필드 : 흐름 제어에 사용되며, 수신자가 받아들이려는 바이트의 크기를 나타내는데 사용
  - 4비트 헤더 길이 필드(Header Length Field) : 32비트 워드 단위로 TCP 헤더 길이를 나타내며, TCP 헤더는 TCP 옵션(Option) 필드 때문에 가변적인 길이가 될 수 있음 (일반적으로, 옵션 필드는 일반적인 TCP 길이가 20바이트가 되도록 비어 있음)
  - 옵션 필드 (Option Field) : 선택적이고 가변적인 길이로서, 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용되며, 타임스탬프 옵션 또한 정의
  - 6비트 플래그 필드(Flag Field)
    + ACK 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는데 사용 (즉, 이 세그먼트는 성공적으로 수신된 세그먼트에 대한 확인 응답을 포함)
    + RST, SYN, FIN 비트 : 연결 설정과 해제에 사용
    + PSH 비트 : 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킴
    + URG 비트 : 세그먼트에서 송신 측 상위 개체가 긴급으로 표시하는 데이터임을 가리킴 (긴급 데이터의 마지막 바이트의 위치는 1비트의 긴급 데이터 포인터 필드(Urgent Data Pointer Field)에 의해 가리켜짐)
      * TCP는 긴급 데이터가 존재할 때, 수신 측 상위 계층 개체에게 통지해야 하고, 긴급 데이터 끝에 대한 포인터를 전달

3. 순서 번호와 확인 응답 번호
   - TCP 세그먼트 헤더에서 가장 중요한 필드 두 가지 : 순서 번호 필드와 확인 응답 필드 (TCP 신뢰적 데이터 전송 서비스의 중요 부분)
   - 💡 TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 봄
     + TCP의 순서 번호, 사용은 순서 번호가 일련의 전송된 세그먼트에 대해서가 아닌, 전송된 바이트 스트림에 대한 관점을 반영
     + 세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호

   - 예제
<div align="center">
<img src="https://github.com/user-attachments/assets/2f3d661e-36a2-401d-ab13-6fbb277c8d43">
</div>

  - 호스트 A에서의 프로세스는 TCP 연결 상에서 호스트 B의 프로세스로 데이터 스트림을 전송하기 원한다고 가정
  - 호스트 A의 TCP는 데이터 스트림의 각 바이트에 암시적으로 순서 번호를 지정
  - 데이터 스트림은 500,000바이트로 구성된 파일이락 가정
  - MSS는 1,000 바이트이며, 데이터 스트림의 첫 번째 바이트는 0으로 설정했다고 가정하고, TCP 데이터 스트림으로부터 500개의 세그먼트들을 구성
    + 첫 번째 세그먼트는 순서 번호 0, 두 번째 세그먼트 순서 번호 1000, 세 번쨰 세그먼트 순서 번호 2000과 같은 식으로 할당
    + 각 순서 번호는 적절한 TCP 세그먼트 헤더 내부 순서 번호 필드에 삽입
  - 확인 응답 번호에 대해 TCP는 호스트 A가 호스트 B로 데이터를 송신하는 동안 호스트 B로부터 데이터를 수신하게 해주는 전이중 방식임
    + 호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어온 데이터에 대한 순서 번호를 가짐
    + 💡 호스트 A가 자신의 세그먼트에 삽입하는 확인 응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호
  - 호스트 A가 B로부터 0에서 535까지 번호가 붙은 모든 바이트를 수신했다고 가정
    + 호스트 B로 세그먼트를 송신하려 한다고 가정
    + 호스트 A는 호스트 B의 데이터 스트림에서 536번째 바이트와 그 다음에 오는 바이트를 기다리고 있으므로, 호스트 A는 세그먼트의 확인응답 번호 필드에 536을 삽입하고 이를 B에 송신
  - 호스트 A가 호스트 B로부터 0 ~ 535의 바이트를 포함하는 어떤 세그먼트와 900 ~ 1000 바이트를 포함하는 또 다른 세그먼트를 수신했다고 가정
    + 호스트 A는 536 ~ 899의 바이트를 아직 수신하지 않았으며, 호스트 A는 B의 데이터 스트림을 재생성하기 위해 536번째와 그 다음의 바이트를 아직 기다림
    + 그러므로, B에 대한 A의 다음 세그먼트는 확인 응답 번호 필드에 536을 가질 것임
  - 💡 TCP는 스트림에 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인 응답하므로, 누적 확인 응답 (Cumulative Acknowledgement)를 제공한다고 함
  - 호스트 A가 세 번째 세그먼트(900 ~ 1000 값의 바이트)를 두 번째 세그먼트(536 ~ 899 값의 바이트)가 수신되기 전에 수신
    + 즉, 세 번째 세그먼트는 순서가 틀리게 도착
    + TCP RFC는 이 부분에 대해 어떠한 규칙을 부여하지 않았고, TCP 구현 개발자에게 맡김
    + 기본적으로 2가지 선택 존재
      * 수신자가 순서를 바뀐 세그먼트를 즉시 버림
      * 수신자는 바뀐 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해 대기 (네트워크 대역폭 관점에서 효율적이며, 실제 취하는 방법)
    + 시작 순서 번호가 0이라고 가정했지만, 실제로는 TCP 연결 양쪽 모두 시작 순서 번호를 임의로 선택 : 아직 네트워크에 남아 있던 세그먼트가 같은 두 호스트 간의 나중에 연결(또한 이전의 연결과 같은 포트 번호를 사용해 발생)에서 유효한 세그먼트로 오인될 확률 최소화

4. Telnet
   - RFC 854에서 정의된 텔넷은 원격 로그인을 위해 사용되는 애플리케이션 계층 프로토콜
   - TCP상에서 실행되며, 한 쌍의 호스트들 사이에서 동작하도록 설계
   - 대화형 애플리케이션 (TCP 순서와 확인 응답 번호 설명에 용이)
   - 다만, 패스워드를 포함하는 텔넷 연결에서 전송된 데이터는 암호화되지 않아 도청 공격에 취약하므로, SSH 프로토콜 선호
   - 호스트 A가 호스트 B와 텔넷 세션을 시작한다고 가정
     + 호스트 A는 세션을 시작하므로 클라이언트이며, 호스트 B는 서버
     + 클라이언트에서 사용자가 입력한 문자는 원격 호스트에게 송신
     + 원격 호스트는 각 문자의 복사본을 송신자에게 반송하여 텔넷 사용자의 화면에 표시 (에코 백(Echo Back)은 텔넷 사용자가 보는 문자가 이미 원격 사이트에 수신되고 처리되었음을 나타냄)
     + 각 문자는 사용자가 키를 누르는 시간과 문자가 사용자의 모니터에 표시되는 시간 사이에서 네트워크를 두 번 횡단

<div align="center">
<img src="https://github.com/user-attachments/assets/d44aad35-31b7-4b06-bc7e-81e6327364fd">
</div>

  - 초기 순서 번호가 클라이언트와 서버에 대해 각 42와 79라고 가정
  - 세그먼트 순서 번호는 데이터 필드 안에 있는 첫 번째 바이트 순서 번호임
  - 클라이언트 송신된 첫 번째 세그먼트는 순서 번호 42를 가지며, 서버로부터 송신된 첫 번째 세그먼트는 79를 가짐
  - 확인 응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호
  - 따라서, TCP 연결이 설정된 후 어떤 데이터도 송신되기 전 클라이언트는 바이트 79를 기다리며, 서버는 바이트 42를 기다림
  - 3개의 세그먼트가 송신
    + 첫 번째 세그먼트는 클라이언트에서 서버로 송신 : 데이터 필드 안에 문자 'C'의 1바이트 ASCII 표현을 포함 (순서 번호 필드 안 42를 가지며, 클라이언트가 아직 서버로부터 어떠한 데이터도 수신하지 못했으므로, 첫 번째 세그먼트는 확인 응답 번호 필드에 79를 가짐)
    + 두 번쨰 세그먼트는 서버에서 클라이언트로 송신
      * 수신하는 서버에게 데이터에 대한 확인응답 제공하므로 확인 응답 필드 안에는 43를 넣음으로, 서버는 클라이언트에게 바이트 42를 성공적으로 수신했고, 앞으로 바이트 43을 기다림을 말해줌
      * 문자 'C'를 반대로 반향되도록 하는 것이므로, 이러한 TCP 연결의 서버-클라이언트 데이터 흐름이 최초 순서 번호인 순서 번호인 79를 가짐 (바이트 79는 서버가 보내는 데이터의 맨 첫 번째 바이트)
      * 💡 클라이언트-서버 데이터에 대한 확인응답은 서버와 클라이언트 간에서 데이터를 운반하는 세그먼트 안에서 전달 : 이러한 확인응답은 서버-클라이언트 데이터 세그먼트 상 피기백(Piggyback)된다고 말함
    + 세 번째 세그먼트는 클라이언트에서 서버로 송신 : 서버로부터 수신한 데이터에 대한 확인 응답
      * 이 세그먼트는 빈 데이터 필드를 가지는데, 즉, 확인 응답은 어떤 클라이언트-서버 데이터와 함께 피기백되지 않음
      * 세그먼트는 확인 응답 필드 안에 80을 가짐 (순서 번호 79 바이트를 통해 바이트의 스트림을 클라이언트가 수신했기 때문이므로, 이제는 80으로 시작하는 바이트를 기다림)
      * TCP가 순서 번호 필드를 가지므로 세그먼트 역시 어떤 순서 번호를 가져야 함 (데이터를 포함하지 않더라도 가져야 함)

-----
### 왕복 시간(RTT) 예측과 타임 아웃
-----
1. 타임아웃은 세그먼트가 전송된 시간부터 긍정 확인응답될 때까지 시간인 연결 왕복 시간(Round-Trip Time, RTT)보다 커야 하며, 그렇지 않으면 불필요한 재전송이 발생
2. 왕복 시간 예측
   - SampleRTT로 표시되는 세그먼트에 대한 RTT 샘플 : 세그먼트가 송신된 시간(즉, IP에게 넘겨진 시간)으로부터 그 세그먼트에 대한 긍정 응답이 도착한 시간까지의 시간 길이
   - 모든 전송된 세그먼트에 대해 SampleRTT를 측정하는 대신, 대부분의 TCP는 한 번에 하나의 SampleRTT 측정만을 시행 (즉, 어떤 시점에서 SampleRTT는 전송되었지만, 현재까지 확인 응답이 없는 세그먼트 중 하나에 대해서만 측정되며, 이는 대략 왕복 시간마다 SampleRTT의 새로운 값을 얻게 함)
   - TCP는 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않으며, 한 번 전송된 세그먼트에 대해서만 측정
   - SampleRTT 값은 라우터에서의 혼잡과 종단 시스템에서의 부하 변화 때문에 세그먼트마다 다르며, 불규칙적인 값이므로 대체로 RTT를 추정하기 위해 SampleRTT의 평균값을 채택
   - 따라서, TCP는 SampleRTT 값의 평균(EstimatedRTT)을 유지
     + 긍정 확인 응답을 수신하고 새로운 SampleRTT를 획득하자마자 TCP는 다음 공식에 따라 갱신
<div align="center">
<img src="https://github.com/user-attachments/assets/c4b72427-c343-4fa6-a3d6-b3224c618b6b">
</div>

   - EstimatedRTT의 새로운 값은 이전 값과 새로운 값의 가중된 조합이며, 권장되는 값은 α = 0.125
   - 즉, EstimatedRTT는 SampleRTT 값의 가중 평균(Weighted Average)
     + 가중평균은 예전 샘플보다 최근 샘플에 더 높은 가중치를 줌
     + 최신 샘플들은 네트워크 상에 현재 혼잡을 더 잘 반영함
     + 통계에서는 이런 평균을 지수적 가중 이동 평균(Exponential Weighted Moving Average, EWMA) : 주어진 SampleRTT의 가중치가 갱신 절차에 진행됨에 따라 빠르게 지수적으로 감소하므로 EWMA에서 지수적이라는 용어가 사용

<div align="center">
<img src="https://github.com/user-attachments/assets/19140bcd-fd9f-49c1-98d8-3697e5db686a">
</div>

   - SampleRTT의 변화가 EstimatedRTT 계산에서 완만하게 됨을 보여줌
   - RTT 예측 외에 RTT의 변환율을 측정하는 것도 유용 : RTT 변화율을 의미하는 DevRTT를 SampleRTT가 EstimatedRTT로부터 얼마나 많이 벗어났는지에 대한 예측으로 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/f653451c-bd2d-49c4-98f0-a31f4771bc94">
</div>

   - DevRTT는 SampleRTT와 EstimatedRTT 값 차이의 EWMA
   - 만일 SampleRTT 값이 어떠한 변화도 없다면, DevRTT는 작을 것이며, 그렇지 않다면 클 것이고, β = 0.2가 권장값

3. 재전송 타임아웃 주기의 설정과 관리
   - TCP 타임 아웃 주기는 EstimatedRTT보다 너무 크면 안 되며, 너무 크면 세그먼트를 잃었을 때 TCP는 즉각적인 세그먼트 재전송을 하지 않게 됨
   - 이 때문에, 애플리케이션에서 전송 지연이 발생하므로, EstimatedRTT에 약간의 여윳값을 더한 값으로 설정하는 것이 바람직
   - SampleRTT 값에 많은 변동이 있을 때 여윳값이 커야 하며, 변동이 작을 때는 작아야 함 (즉, DevRTT 값이 그 역할을 함)
   - 이러한 모든 고려사항은 재전송 타임아웃 주기를 결정하는 TCP 방식에 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/48858b36-02b4-4795-9c85-b00ef39a3424">
</div>

   - 초기 TimeoutInterval의 값으로 1초를 권고
   - 타임아웃이 발생하면 TimeoutInterval의 값은 두 배로 하여 조만간 확인 응답할 후속 세그먼트에게 발생할 수 있는 조기 타임아웃을 피다로고 함
   - 그러나 세그먼트가 수신되고, EstimatedRTT가 수정되면 TimeoutInterval은 다시 위 공식에 따라 계산
