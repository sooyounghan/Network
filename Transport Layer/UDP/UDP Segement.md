-----
### UDP 세그먼트 구조
-----
1. RFC 768에 정의
<div align="center">
<img src="https://github.com/user-attachments/assets/6dc5e534-e108-4af2-8be5-5dc270965920">
</div>

2. 애플리케이션 데이터는 UDP 데이터그램 데이터 필드에 위치
   - DNS에 대한 데이터 필드는 질의 메세지나 응답 메세지 포함
   - 스트리밍 오디오 애플리케이션에는 오디오 샘플이 데이터 필드를 채움

3. UDP 헤더는 2바이트씩으로 구성된 단 4개의 필드만을 가짐
   - 포트 번호는 목적지 호스트가 목적지 종단 시스템에서 동작(역다중화 기능 수행)하는 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해줌
   - 체크섬(Checksum)은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용 (UDP 세그먼트 외에도 IP 헤더의 일부 필드도 계산)
   - 길이 필드는 헤더를 포함하는 UDP 세그먼트의 길이(바이트 단위)를 나타냄

4. UDP 체크섬
   - 오류 검출을 위한 필드
   - 세그먼트가 출발지로부터 목적지로 이동했을 때(예) 링크의 잡음에 의해 라우터에서 저장되는 동안), UDP 세그먼트 안 비트에 대한 변경사항이 있는지 검사
   - 송신자 측에서 UDP는 세그먼트 안에 있는 모든 16비트 워드의 합산에 대해 1의 보수를 수행하며, 합산 과정에서 발생하는 오버플로우는 윤회식 자리올림(Wrap Around) 수행
   - 이 결과값이 UDP 세그먼트 체크섬 필드에 삽입
   - 예시) 3개의 16비트 워드가 존재
```
0110011001100000
0101010101010101
1000111100001100
```
   - 이러한 16비트 워드에서 처음 2개 워드 합
```
0110011001100000
0101010101010101
----------------
1011101110110101
```
   - 앞 계산 합에 세 번째 워드를 더하면 다음과 같은 결과
```
1011101110110101
1000111100001100
----------------
0100101011000010
```
   - 마지막 합은 오버플로우(자리 넘침)가 있으므로 윤회식 자리올림 시행
   - 1의 보수 : 모든 0을 1로 변환, 모든 1을 0으로 변환
   - 따라서, 합의 1의 보수는 1011010100111101이고, 이것이 체크섬이 됨
   - 수신자에서는 체크섬을 포함한 4개의 모든 16비트 워드들이 더해지는데, 만약 어떠한 패킷에도 오류가 없다면 수신자에서 합은 1111111111111111이 될 것이며, 하나라도 0이 있다면 패킷에 오류가 발생한 것
   - 제공 이유
     + 출발지와 목적지 사이 모든 링크가 오류 검사를 제공한다는 보장이 없음 (즉, 링크 중 하나가 오류 검사를 제공하지 않는 프로토콜을 사용할 수 있음)
     + 따라서, 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터에 메모리에 저장될 때 비트 오류가 바랭할 수 있음
     + 그러므로 주어진 링크 간 신뢰성과 메모리 오류 검사가 보장되지 않고, 종단 간 데이터 전송 서비스가 오류 검사를 제공해야 한다면, UDP는 종단 기반으로 트랜스포트 계층에서 오류 검사를 제공해야 함 : 종단과 종단의 원칙(End-End Principle)의 한 예
     + 즉, 어떤 기능이(이 경우 오류 검사) 종단 기반으로 구현되어야함
   - IP는 어떠한 2계층 프로토콜에서도 동작해야 하므로, 트랜스포트 게층은 오류 검사를 제공하는 것이 유용
   - UDP는 오류 검사를 제공하지만, 오류를 회복하지 위해 어떠한 일도 하지 않음 (일부 UDP 구현에서는 손상된 세그먼트를 버리기도 하고, 경고와 함께 손상된 세그먼트를 애플리케이션에게 넘겨주기도 함)
