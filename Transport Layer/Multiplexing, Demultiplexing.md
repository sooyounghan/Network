-----
### 다중화와 역다중화
-----
1. 목적지 호스트에서의 트랜스포트 계층은 아래의 네트워크 계층으로부터 세그먼트를 수신
2. 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 가짐
3. 네트워크 애플리케이션은 프로세스가 소켓(Socket)을 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/3af4f70d-a3ce-4045-90d1-6938c27b94da">
</div>

   - 수신 측 호스트 트랜스포트 계층은 데이터를 직접 프로세스에 전달하지 않으며, 중간 매개자인 소켓에게 전달
   - 어떤 주어진 시간에 수신 측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각 소켓은 하나의 유일한 식별자를 가지는데 소켓이 UDP 소켓인지, TCP 소켓인지 따라 달라짐
   - 각 트랜스포트 계층 세그먼트는 이러한 목적을 위해 세그먼트에 필드 집합을 가지는데, 수신 측 트랜스포트 계층은 수신 소켓을 식별하기 위해 필드를 검사하며, 이후 세그먼트를 해당 소켓에 보냄
   - 역다중화(Demultiplexing) : 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓에 전달하는 작업
   - 다중화(Multiplexing) : 출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보(역다중화에 사용)로 캡슐화하고, 그 세그먼트들을 네트워크 게층으로 전달하는 작업
   - 중간 호스트의 트랜스포트 계층들은 네트워크 계층 아래로부터 수신한 세그먼트를 프로세스 $P_{1}$ 또는 $P_{2}$로 반드시 역다중화해야하며, 도착한 세그먼트의 데이터가 이에 상응하는 프로세스 소켓으로 전달되도록 해서 이루어져야 함
   - 또한, 중간 호스트의 트랜스포트 계층은 프로세스 소켓으로부터 외부로 나가는 데이터를 모으고, 다음엔 트랜스포트 계층 세그먼트들로 만들고, 이 세그먼트들을 아래 네트워크 계층으로 전달해야만 함

4. 소켓은 유일한 식별자를 가지며, 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 가짐
   - 출발지 포트 번호 필드(Source Port Number Field), 목적지 포트 번호 필드(Destination Port Number Field)
   - 각 포트 번호는 0 ~ 65535까지의 16비트 정수며, 0 ~ 1023까지 포트 번호를 잘 알려진 포트 번호(Well-Known Port Number)라고 하여 사용을 엄격히 제한 (RFC 1700에 명시)
<div align="center">
<img src="https://github.com/user-attachments/assets/ff5d9c23-f2c6-4d69-bded-ec56dfb79c07">
</div>

   - 호스트의 각 소켓은 포트 번호를 할당 받으며, 세그먼트가 호스트에 도착하면, 트랜스포트 계층은 세그먼트 안 목적지 포트 번호를 검사하고 상응하는 소켓으로 세그먼트를 보내게 됨
   - 세그먼트 데이터는 소켓을 통해 해당되는 프로세스로 전달

-----
### 비연결형 다중화와 역다중화
-----
1. 애플리케이션 서버 측이 특정 포트 번호를 할당하는 것에 반해, 애플리케이션 클라이언트 측은 트랜스포트 계층이 포트 번호를 자동으로 할당
2. 예를 들어, UDP 소켓 19157을 가진 호스트 A 프로세스가 호스트 B의 UDP 소켓 46428을 가진 프로세스에게 애플리케이션 데이터 전송을 원한다고 가정
   - 호스트 A의 트랜스포트 계층은 애플리케이션 데이터, 출발지 포트 번호(19157), 목적지 포트 번호(46428)과 2개의 다른 값을 포함하는 트랜스포트 계층 세그먼트 생성
   - 트랜스포트 계층은 만들어진 세그먼트를 네트워크 계층으로 전달하며, 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하고 최선형 전달 서비스로 세그먼트를 수신 호스트로 전달
   - 수신 호스트 B에 도착하면, 수신 호스트는 세그먼트 안의 목적지 포트 번호(46428)을 검사하고, 그 세그먼트를 포트 46428로 식별되는 소켓에 전달
   - 호스트 B에 여러 프로세스가 수행될 수 있는데, 이 때 프로세스들은 각 UDP 소켓과 그와 연관된 포트 번호를 가지며, 따라서 네트워크로부터 UDP 세그먼트들이 도착하면, 호스트 B는 세그먼트 목적지 포트를 검사해 세그먼트를 적절한 소켓으로 보냄 (역다중화)
   - 즉, UDP 소켓이 목적지 IP 주소와 목적지 포트 번호로 구성된 두 요소로 된 집합에 의해 식별되며, 2개의 UDP 세그먼트가 출발지 IP 주소와 출발지 포트 번호가 모두 다르거나 출발지 IP 주소와 출발지 포트 번호 중 어느 하나가 다를지라도, 같은 목적지 IP 주소와 목적지 포트 번호를 가지면 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향함
<div align="center">
<img src="https://github.com/user-attachments/assets/629c486c-2cf3-4f38-91ec-77872a64734f">
</div>

-----
### 연결지향형 다중화와 역다중화
-----
1. TCP 소켓은 4개의 요소 집합 (출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호)에 의해 식별되며, 네트워크로부터 호스트에 TCP 세그먼트가 도착하면, 호스트는 해당되는 소켓으로 세그먼트를 전달(역다중화)하기 위해 4개의 값을 모두 사용
   - UDP와는 다르게 출발지 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트(초기 연결 설정 요청을 전달하는 TCP 제외) 2개의 다른 소켓으로 향하게 됨

2. TCP 서버 애플리케이션은 '환영 소켓'을 가지며, 이 소켓은 포트 번호 12000을 가진 TCP 클라이언트로부터 연결 설정 요청을 기다린다고 가정
   - 그러면, TCP 클라이언트는 소켓을 생성하고 연결 설정 요청 세그먼트를 보냄
   - 연결 설정 요청은 목적지 포트 번호 12000과 TCP 헤더에 설정된 특별한 연결 설정 비트를 가진 TCP 세그먼트에 지나지 않음
   - 또한, 그 세그먼트는 출발지 포트 번호를 포함하는데, 이는 클라이언트가 선택한 번호
   - 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트 12000을 포함하는 연결 요청 세그먼트를 수신하면, 이 세그먼트를 포트 번호 12000으로 연결 수락을 기다리는 서버 프로세스로 보냄
   - 또한, 서버는 연결 요청 세그먼트의 4가지 값으로 식별 (세그먼트 안의 출발지 포트 번호, 출발지 호스트의 IP 주소, 세그먼트 안의 목적지 포트 번호, 목적지 IP 주소) : 새롭게 생성된 연결 소켓은 4가지 값에 의해 식별
   - 그 다음에 도착하는 네 가지 값과 일치하면, 세그먼트는 이 소켓으로 역다중화가 될 것이며, 적절한 TCP 연결과 함께 클라이언트와 서버는 데이터를 주고 받음

3. 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있으며, 각 소켓은 프로세스에 접속되어있고, 이들 소켓은 4개 요소 집합에 의해 식별
   - TCP 세그먼트가 호스트에 도착하면, 이 네 가지 필드 모두 해당되는 소켓으로 세그먼트를 전달하기 (역다중화) 위해 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/7a3b23ce-01b1-49fb-8907-eda5528df413">
</div>

   - 호스트 C가 서버 B로 2개의 HTTP 세션을 시작하고, 호스트 A가 호스트 B로 하나의 HTTP 세션을 시작하는 상황이 설명
   - 호스트 A와 호스트 C, 그리고 서버 B는 각자 유일한 IP 주소인 A, C, B를 각각 갖고 있음
   - 호스트 C는 2개의 출발지 포트 번호(26145와 7532)를 자신의 HTTP 연결에 할당
   - 호스트 A는 C와 독립적으로 출발지 포트 번호를 선택하므로, 이것 또한 HTTP 연결에 출발지 포트로 26145를 할당할 수 있음
   - 그렇게 하더라도, 2개의 연결은 다른 출발지 IP 주소를 가지므로 서버 B는 같은 출발지 포트 번호를 가진 두 연결을 여전히 올바르게 역다중화할 수 있음

-----
### 웹 서버와 TCP
-----
1. 아파치 웹 서버와 같은 웹 서버가 포트 번호 80 상에 동작하는 호스트를 고려
   - 클라이언트가 서버로 세그먼트를 보내면, 모든 세그먼트는 목적지 포트 번호 80을 갖고 있을 것
   - 서버는 각기 다른 클라이언트가 보낸 세그먼트를 출발지 IP 주소와 출발지 포트 번호로 구별

2. 웹 서버가 각 연결에 따라 새로운 프로세스를 만드는 것을 볼 수 있는데, 이들 프로세스는 각자 연결 소켓을 가지며, 이 연결 소켓을 통해 HTTP 요청을 수신하고, HTTP 응답을 전송
3. 그러나 항상 연결 소켓과 프로세스 사이 항상 일대일 대응이 이루어지는 것이 아니며, 오늘날 많은 고성능 웹 서버는 하나의 프로세스만을 사용하면서, 각 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드(가벼운 서브프로세스) 생성
4. 즉, 웹 서버에서는 하나의 같은 프로세스에 붙어 있는 많은 연결 소켓들(다른 식별자를 가진)이 동시에 존재할 수 있음
5. 만약, 클라이언트와 서버가 지속적인(Persistent) HTTP를 사용한다면, 지속적인 연결의 존속 기간에 클라이언트와 서버는 같은 소켓을 통해 HTTP 메세지를 교환할 것이며, 비지속적인(Non-Persistent) HTTP를 사용한다면, 모든 요청/응답마다 새로운 TCP 연결이 생성되고 종료될 것이므로 웹 서버 성능에 부담을 줌
